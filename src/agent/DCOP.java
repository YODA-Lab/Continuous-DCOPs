package agent; //dcop

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Serializable;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import behaviour.AGENT_TERMINATE;
import behaviour.BROADCAST_RECEIVE_HEURISTIC_INFO;
import behaviour.DPOP_UTIL;
import behaviour.PSEUDOTREE_GENERATION;

import behaviour.SEARCH_NEIGHBORS;

import function.BinaryFunction;
import function.Interval;
import function.PiecewiseFunction;
import table.Row;
import table.Table;
import transition.TransitionFunction;
import jade.core.AID;
import jade.core.Agent;
import jade.core.behaviours.SequentialBehaviour;
import jade.domain.DFService;
import jade.domain.FIPAException;
import jade.domain.FIPAAgentManagement.DFAgentDescription;
import jade.domain.FIPAAgentManagement.ServiceDescription;
import jade.lang.acl.ACLMessage;

/* Each agent is a node in the graph
 * The graph is presented as pseudo-tree
 * Pseudo-tree is generated by Distributed DFS
 * 
 * Each Agent has a "root" flag to indicate root or not
 * Each Agent has a local name which is an ID number and is assigned by constructor.
 * Based on the ID number, each agent has a fixed number neighbors, which is instantiated
 * by the constructor
 * 
 * ****PROCESS OF FINDING AID NEIGHBORS
 * Each Agent has a list of neighbors, and register his neighbors ID number to DF
 * Each Agent find his neighbors' AIDs by searching DF which agents register the Agent's ID numbers as
 * a neighbor. The add to his list of AID neighbors.
 * 
 * The process of finding AIDs only stops when the number of recognized AID is the number of his neighbors
 * 
 * ****PROCESS OF GENERATING PSEUDOTREE
 * Each agent always listens to the first messages, while trying to finish the searching process
 * After finishing the searching process, he begins to process the messages and send the message to his
 * neighbors.
 * 
 * Agent root start sending messages when finish searching agents.
 * 
 * Each agents will print out his parent, his children, his pseudo-parents, his pseudo-children
 * 
 * ****PROCESS OF DPOP
 * DPOP starts when the PSEUDOTREE PROCESS FINISHED
 */
public class DCOP extends Agent implements DcopInfo {
	
	private static final long serialVersionUID = 2919994686894853596L;
	
    public int algorithm;
    public int h;   //timeStep where the Markov chain is converged
    public String inputFileName;
	public String varDecisionFileName;
	public int domainMax; //from 0 - domain
	public Interval globalInterval;

	private Map<String, ArrayList<Double>> bestValueMap;
	private Map<String, ArrayList<Double>> agentView_DPOP_TSMap;

	private String idStr;
	private boolean isRoot;
	private boolean isLeaf;
	
	private AID	parentAID;
	private List<AID> childrenAIDList;
	private List<AID> neighborAIDList; 
	private List<AID> pseudoParentAIDList;
	private List<AID> pseudoChildrenAIDList;
	private List<String> parentAndPseudoStrList;
	private List<String> neighborStrList;
//	private List<String> childrenStrList;
	
	private List<Table> currentTableListDPOP;
	private List<Table> constraintTableWithoutRandomList;
	private List<Table> organizedConstraintTableList;
	
	private HashMap<String, ArrayList<String>> decisionVariableDomainMap;
	//map TS -> constraint table list (if local_search)
	//map TS -> 1 collapsed table list (if collapsed dpop)
	private HashMap<Integer, ArrayList<Table>> constraintTableAtEachTSMap;
	private Table collapsedSwitchingCostTable;
	
	//VALUE phase
	HashMap<String, Double> valuesToSendInVALUEPhase;
	
	//used for LOCAL SEARCH
	private HashMap<Integer, Double> valueAtEachTSMap;
	//ArrayList<Double> utilityAtEachTSList;
	//agent -> <values0, values1, ..., values_n>
    private ArrayList<Double> currentGlobalUtilityList;
    private ArrayList<String> bestImproveValueList;
    private double currentGlobalUtility;
    private double totalGlobalUtility;
    private double utilFromChildrenLS;
		
    private Table agentViewTable;
    private Double chosenValue;
    private HashMap<Integer, String> pickedRandomMap;

	private int currentTS;
	
    private long startTime;
    private long endTime;
    private long currentUTILstartTime;
	private int lsIteration;

	//simulated time
	private ThreadMXBean bean;
    private long simulatedTime = 0;
    private long currentStartTime;
    private static long delayMessageTime = 0;
    
    //for reuse information
    private HashMap<AID, Integer> constraintInfoMap;
    private boolean notVisited = true;
	
//	ArrayList<String> neighborWithRandList;
	
    //for writing file
    private double oldLSUtility = 0;
	private double oldLSRunningTime = 0; //old running time because compare to see if old iteration is converged
	private boolean stop = false;
	public int noAgent;
	private double utilityAndCost;
	private String lastLine;
	
	private List<PiecewiseFunction> functionList;
	private PiecewiseFunction agentViewFunction;
	private List<PiecewiseFunction> currentFunctionListDPOP;

	public DCOP() {
		initializeArguments();
		isRoot = false;
		isLeaf = false;
		totalGlobalUtility = 0;
		lsIteration = 0;
		utilFromChildrenLS = 0;
		currentTS = 0;
		functionList = new ArrayList<>();
	}
	
	//done with LS-RAND
	public void readArguments() {
    	Object[] args = getArguments();
		//parameters for running experiments
		algorithm = Integer.valueOf((String) args[0]);
//		inputFileName = "rep_6_d8.dzn";
		inputFileName = (String) args[1];
		
//		String a[] = inputFileName.replaceAll("rep_","").replaceAll(".dzn","").split("_d");
//		noAgent = Integer.valueOf(a[1]);
		noAgent = 4;
		idStr = getLocalName();
		h = 0;
		
//		agentView_DPOP_TSMap.put("next", new ArrayList<Double>());
//		agentView_DPOP_TSMap.put("further", new ArrayList<Double>());
		
		//can be done after getting the algorithm
		if (algorithm == DPOP) {
			constraintTableAtEachTSMap.put(0, new ArrayList<Table>());
		}
		else if (algorithm == DSA) {
			constraintTableAtEachTSMap.put(0, new ArrayList<Table>());
		}
	}
	
    protected void setup() {
    	readArguments();
		if (idStr.equals("1")) {
			System.out.println("alg " + algorithm);
//			System.out.println("iter " + MAX_ITERATION);
 			System.out.println("input " + inputFileName);
			System.out.println("ts " + h);
//			System.out.println("id " + instanceD);
			isRoot = true;

		}

		readMinizincFileThenParseNeighborAndConstraintTable(inputFileName);		
		/***** START register neighbors with DF *****/ 
		registerWithDF();
		/***** END register neighbors with DF *****/ 
				
		// add constraints table FROM constraintTableWithoutRandomList TO organizedConstraintTableList
		reorganizeConstaintTable();
		
		if (algorithm == DSA) {
//		    createNonProcessTable();
//		    createProcessedTable();
		}
		
//        Interval interval = new Interval(0, domainMax);
		
		// HARD-CODED binary function
//		if (idStr.equals("1")) {
//
//		}
//		if (idStr.equals("2")) {
////		    BinaryFunction func = new BinaryFunction(1, 20, -3, 40, -2, 6, Double.valueOf(idStr), 1.0);
//		    BinaryFunction func = new BinaryFunction(-1, 20, -3, 40, -2, 6, Double.valueOf(idStr), 1.0);
//		    func.setSelfInterval(interval);
//	        func.setOtherInterval(interval);
//            PiecewiseFunction pwFunc = new PiecewiseFunction(Double.valueOf(idStr), 1.0);
//            pwFunc.addNewFunction(func);
//            functionList.add(pwFunc);		
//        }
//        if (idStr.equals("3")) {
//            BinaryFunction func = new BinaryFunction(1, 10, -3, 30, -2, 6, Double.valueOf(idStr), 1.0);
//            func.setSelfInterval(interval);
//            func.setOtherInterval(interval);
//            PiecewiseFunction pwFunc = new PiecewiseFunction(Double.valueOf(idStr), 1.0);
//            pwFunc.addNewFunction(func);
//            functionList.add(pwFunc);
//        }
		
//		if (algorithm == LS_RAND)
//			for (int ts=0; ts<=h; ts++) {
//				addExpectedRandomTableToList(ts);
//				addConstraintTableToList(ts);
//			}

		if (algorithm == DPOP) {
//			addExpectedRandomTableToListAllTS();
//			addConstraintTableToListAllTS();
		}		
		else if (algorithm == DSA) {
			addConstraintTableToListAllTS();
		}
		

		startTime = System.currentTimeMillis();
		bean = ManagementFactory.getThreadMXBean();
		bean.setThreadContentionMonitoringEnabled(true);
		
		SequentialBehaviour mainSequentialBehaviourList = new SequentialBehaviour();
		mainSequentialBehaviourList.addSubBehaviour(new SEARCH_NEIGHBORS(this));
		mainSequentialBehaviourList.addSubBehaviour(new BROADCAST_RECEIVE_HEURISTIC_INFO(this));
		mainSequentialBehaviourList.addSubBehaviour(new PSEUDOTREE_GENERATION(this));
		
		//run DPOP multi-step
		if (algorithm == DPOP) {
			mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this));
//			mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this));
		}
		
		mainSequentialBehaviourList.addSubBehaviour(new AGENT_TERMINATE(this));
		addBehaviour(mainSequentialBehaviourList); 
	}
	
	//JADE function: stop the Agent
	protected void takeDown() {	
		endTime = System.currentTimeMillis();
		System.out.println("Agent " + idStr + " has RUNNING TIME: " + (endTime - startTime) + "ms");
		System.out.println("Agent " + idStr + " with threadID " + Thread.currentThread().getId() + 
								" has SIMULATED TIME: " + simulatedTime/1000000 + "ms");
		System.out.println("Agent " + idStr + " with threadID " + Thread.currentThread().getId() + 
				" has sim TIME: " + bean.getCurrentThreadUserTime()/1000000 + "ms");
		System.err.println("Agent: " + getAID().getName() + " terminated.");
		try {
			DFService.deregister(this);
		} catch (FIPAException e) {
			e.printStackTrace();
		}
	}

	public void initializeArguments() {
		neighborStrList = new ArrayList<>();
		neighborAIDList = new ArrayList<>();
		childrenAIDList = new ArrayList<>();
		pseudoParentAIDList = new ArrayList<>();
		pseudoChildrenAIDList = new ArrayList<>();
		parentAndPseudoStrList = new ArrayList<>();
		currentTableListDPOP = new ArrayList<>();
		constraintTableWithoutRandomList = new ArrayList<>();
		organizedConstraintTableList = new ArrayList<>();
		decisionVariableDomainMap = new HashMap<String, ArrayList<String>>();
		constraintTableAtEachTSMap = new HashMap<Integer, ArrayList<Table>>();
		valueAtEachTSMap = new HashMap<Integer, Double>();

		bestValueMap = new HashMap<String, ArrayList<Double>>();
		bestValueMap.put("next", new ArrayList<>());
		bestValueMap.put("further", new ArrayList<>());
		agentView_DPOP_TSMap = new HashMap<String, ArrayList<Double>>();

		currentGlobalUtilityList = new ArrayList<>();
		bestImproveValueList = new ArrayList<String>();
		constraintInfoMap = new HashMap<AID, Integer>();
		valuesToSendInVALUEPhase = new HashMap<String, Double>();
		pickedRandomMap = new HashMap<Integer, String>();
		lastLine = "";
	}
	
	// Whether Row from Processed or Non Processed is inputed from the caller
	public int countViolated(boolean isProcess, boolean isNext, Row row, ArrayList<Double> agent_view) {
		int count = 0;
		int index_agentView = (isProcess == NON_PROCESSED) ? 0 : 2;
		int index_row = (isNext == IS_NEXT) ? 0 : 2;
		
		ArrayList<Double> rowValueList = row.getValueList();

		if (Double.compare(rowValueList.get(index_row), agent_view.get(index_agentView+1)) != 0) count++;
		if (Double.compare(rowValueList.get(index_row+1), agent_view.get(index_agentView)) != 0) count++;
		
		return count;
	}
	
	ArrayList<ArrayList<String>> getAllTupleValueOfGivenLabel(ArrayList<String> varLabel, boolean isDecVar) {
		ArrayList<ArrayList<String>> allTuple = new ArrayList<ArrayList<String>>();
		ArrayList<Integer> sizeDomainList = new ArrayList<Integer>();
		int totalSize = 1;
		for (String randVar:varLabel) {
			int domainSize = 0;
			
			if (isDecVar) {
				domainSize = decisionVariableDomainMap.get(randVar).size();
			}
//			else
//				domainSize = randomVariableDomainMap.get(randVar).size();
			sizeDomainList.add(domainSize);
			totalSize *= domainSize;
		}
		
		int noVar = varLabel.size();
		
		//go from 0 to totalSize
		for (int count=0; count<totalSize; count++) {
			ArrayList<String> valueTuple = new ArrayList<String>();
			int quotient = count;
			//for each value count, decide the index of each column, then add to the tuple
			for (int varIndex = noVar-1; varIndex>=0; varIndex--) {
				int remainder = quotient%sizeDomainList.get(varIndex);
				quotient = quotient/sizeDomainList.get(varIndex);
				if (isDecVar)
					valueTuple.add(decisionVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
//				else 
//					valueTuple.add(randomVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
			}
			Collections.reverse(valueTuple);
			allTuple.add(valueTuple);
		}
		
		return allTuple;
	}
	
	void reorganizeConstaintTable() {
		//traverse each constraint table in constrainTableList
		//create new constraintTableList
		for (Table constraintTable:constraintTableWithoutRandomList) {
			organizedConstraintTableList.add(constraintTable);
		}
	}
	
	boolean isConstraintTableAtEachTSMapNull(int indexInConstraintTableMap) {
		ArrayList<Table> tableList = constraintTableAtEachTSMap.get(indexInConstraintTableMap);
		if (tableList == null)	return true;
		else	
			return false;
	}
	
	public void addConstraintTableToList(int timeStep) {
		// traverse table in organizedConstraintTableList
		for (Table decTable : organizedConstraintTableList) {
			ArrayList<Double> decLabel = decTable.getDecVarLabel();
			// for each table, run time step from 0 to allowed
			// for (int tS=0; tS<=solveTimeStep; tS++) {
			Table newTable = new Table(decLabel);

			// at each timeStep, traverse rows
			for (Row row : decTable.getTable()) {
				double updatedUtility = 0;
				updatedUtility = row.getUtility();
				newTable.addRow(new Row(row.getValueList(), updatedUtility));
			}
			constraintTableAtEachTSMap.get(timeStep).add(newTable);
		}
	}
	public void addConstraintTableToListAllTS() {		
		//traverse table in organizedConstraintTableList
		for (Table decTable:organizedConstraintTableList) {
			ArrayList<Table> tableAtTSList = new ArrayList<Table>();
			ArrayList<Double> decLabel = decTable.getDecVarLabel();
			//for each table, run time step from 0 to allowed
			for (int tS=0; tS<=h; tS++) {
				Table newTable = new Table(decLabel);
				
				//at each timeStep, traverse rows
				for (Row row:decTable.getTable()) {
					double updatedUtility = 0;
					updatedUtility = row.getUtility();
					newTable.addRow(new Row(row.getValueList(), updatedUtility));
				}
				if (algorithm == DPOP) {
					tableAtTSList.add(newTable);
				}
				else if (algorithm == DSA) {
					constraintTableAtEachTSMap.get(tS).add(newTable);
				}
//				else if (algorithm == LS_RAND) { 
//					constraintTableAtEachTSMap.get(tS).add(newTable);
//				}
			}
			if (algorithm == DPOP) {
//				constraintTableAtEachTSMap.get(0).add(joinConstraintTable(tableAtTSList));
                constraintTableAtEachTSMap.get(0).add(tableAtTSList.get(0));
			}
		}
	}
	
	//they have the same entry, only different utility
//	public Table joinConstraintTable(ArrayList<Table> tableList) {
//		if (tableList.size() == 0) return null;
//		Table joinedTable = new Table(tableList.get(0).getDecVarLabel());
//		int noVar = tableList.get(0).getDecVarLabel().size();
//		int entryNumber = tableList.get(0).getRowCount();
//		int noTable = tableList.size();
//		int totalSize = (int) Math.pow(entryNumber, noTable);
//		
//		for (int count=0; count<totalSize; count++) {
//			ArrayList<Double> valueTuple = new ArrayList<Double>(noVar);
//			for (int i=0; i<noVar; i++) valueTuple.add("");
//			double sumUtility = 0;
//			int quotient = count;
//			//for each table count, decide the index of each column, then add to the tuple
//			for (int tableIndex = noTable-1; tableIndex>=0; tableIndex--) {
//				int remainder = quotient%entryNumber;
//				quotient = quotient/entryNumber;
//				Row row = tableList.get(tableIndex).getTable().get(remainder);
//				sumUtility += row.getUtility();
//				ArrayList<Double> valueList = row.getValueList();
//				for (int idx=0; idx<valueList.size(); idx++) {
//					valueTuple.set(idx, valueList.get(idx) + "," + valueTuple.get(idx));
//				}
//			}
//			for (int idx=0; idx<valueTuple.size(); idx++) {
//				valueTuple.set(idx, valueTuple.get(idx).substring(0, valueTuple.get(idx).length()-1));
//			}
//			joinedTable.addRow(new Row(valueTuple, sumUtility));
//		}
//	
//		return joinedTable;
//	}

//	public void addExpectedRandomTableToList(int timeStep) {
//		//loop over number of each organized constraint random table
//		for (Table randTable:organizedConstraintTableWithRandomList) {
//			ArrayList<String> decLabel = randTable.getDecVarLabel();
//			ArrayList<String> randLabel = randTable.getRandVarLabel();
//			
//			int randDomainSize = 1;
//			for (String randVar:randLabel) {
//				randDomainSize *= randomVariableDomainMap.get(randVar).size();
//			}
//							
//			Table tempTable;				
//			tempTable = randTable;
//			Table newTable = new Table(decLabel);
//			double expectedUtility = 0;
//			//traverse rows
//			for (int index=0; index<tempTable.getRowCount(); index++) {
//				Row row = tempTable.getTable().get(index);
//				ArrayList<String> decValueList = row.getValueList();
//				ArrayList<String> randValueList = row.getRandomList();
//				double initProb = 1;
//				for (int idx=0; idx<randLabel.size(); idx++) {
//					String rand = randLabel.get(idx);
//					initProb *= probabilityAtEachTimeStepMap.
//							get(rand)[timeStep][randomVariableDomainMap.get(rand).
//										  indexOf(randValueList.get(idx))];
//				}
//				expectedUtility += initProb*row.getUtility();
//				
//				//last turn
//				if (index%randDomainSize == randDomainSize-1) {
//					Row newRow = null;
//					newRow = new Row(decValueList, expectedUtility);
//					newTable.addRow(newRow);
//					expectedUtility = 0;
//				}
//			//end of traversing row
//			}
//			constraintTableAtEachTSMap.get(timeStep).add(newTable);
//		//end of traversing random table
//		}
//	
//	}
	
	//initializing constraintTableAtEachTimeStepMap(timeStep, listOfTables)
	//calculate expected utility, and eliminate random variables
//	public void addExpectedRandomTableToListAllTS() {		
//		//loop over number of each organized constraint random table
//		for (Table randTable:organizedConstraintTableWithRandomList) {
//			ArrayList<Table> tableAtTSList = new ArrayList<Table>();
//			ArrayList<String> decLabel = randTable.getDecVarLabel();
//			ArrayList<String> randLabel = randTable.getRandVarLabel();
//			
//			int randDomainSize = 1;
//			for (String randVar:randLabel) {
//				randDomainSize *= randomVariableDomainMap.get(randVar).size();
//			}
//			
//			//loop over timeStep -> timeStepAllow-1
//			for (int tS=0; tS<=h; tS++) {				
//				Table tempTable;				
//				tempTable = randTable;
//				Table newTable = new Table(decLabel);
//				double expectedUtility = 0;
//				//traverse rows
//				for (int index=0; index<tempTable.getRowCount(); index++) {
//					Row row = tempTable.getTable().get(index);
//					ArrayList<String> decValueList = row.getValueList();
//					ArrayList<String> randValueList = row.getRandomList();
//					double initProb = 1;
//					for (int idx=0; idx<randLabel.size(); idx++) {
//						String rand = randLabel.get(idx);
//						initProb *= probabilityAtEachTimeStepMap.
//								get(rand)[tS][randomVariableDomainMap.get(rand).
//											  indexOf(randValueList.get(idx))];
//					}
//					expectedUtility += initProb*row.getUtility();
//					
//					//last turn
//					if (index%randDomainSize == randDomainSize-1) {
//						Row newRow = null;
//						newRow = new Row(decValueList, expectedUtility);
//						newTable.addRow(newRow);
//						expectedUtility = 0;
//					}
//				//end of traversing row
//				}
//				if (algorithm == C_DPOP) {
//					//add table to tableAtTSList to be joined later
//					tableAtTSList.add(newTable);
//				}
//				else if (algorithm == LS_RAND) { 
//					constraintTableAtEachTSMap.get(tS).add(newTable);
//				}
//				//end of loop timeStep
//			}
//			//at the end of traversing timeStep from 0 -> stableTimeStep,
//			//join all of expected table, and add the joinedTable to timeStep 0
//			//tables at last stableTimeStep been added to last time step
//			if (algorithm == C_DPOP) {
//				constraintTableAtEachTSMap.get(0).add(joinConstraintTable(tableAtTSList));
//			}			
//		//end of traversing random table
//		}
//	}
	
//	public Table collapseGivenRandomTable(Table tableWithRandom) {		
//		Table newlyCreatedTable;
//		ArrayList<ArrayList<String>> processedDecValues = new ArrayList<ArrayList<String>>();
//		
//		ArrayList<String> decVarLabel = tableWithRandom.getDecVarLabel();
//		ArrayList<String> randVarLabel = tableWithRandom.getRandVarLabel();
//		ArrayList<ArrayList<String>> allTupleValue = getAllTupleValueOfGivenLabel(randVarLabel, false);
//		newlyCreatedTable = new Table(decVarLabel, randVarLabel);
//		
//		int noOfEquations = 1;
//		for (String randVar:randVarLabel) {
//			noOfEquations *= randomVariableDomainMap.get(randVar).size();
//		}
//
//		//traverse each row of tableWithRandom
//		for (Row rowToBeTraversed:tableWithRandom.getTable()) {
//			ArrayList<String> decValueList = rowToBeTraversed.getValueList();
//
//			//ArrayList<String> randValueList = rowToBeTraversed.getRandomList();
//			
//			//check if decValueList contained in processedDecValues
//			if (isArrayContainedInOtherArray(processedDecValues,decValueList)) {
//
//				continue;
//			} //search for all values of random Variable
//			else if (isArrayContainedInOtherArray(processedDecValues,decValueList) == false) {
//				processedDecValues.add(decValueList);
//				/** construct unknown equations, by add coefficients
//				 *
//				 * construct coefficients
//				 *  (1-delta*prob[0,0] - delta*prob[0,1] ... - delta*prob[0,n]  = v0
//				 *  -delta*prob[1,0] + (1-delta*prob[1,1] ...- delta*prob[1,n]  = v1
//				 *
//				 *  -delta*prob[n,0] - delta*prob[n,1] ... + (1-delta*prob[n,n] = v_n
//				 **/
//				double coefficients[][] = new double[noOfEquations][noOfEquations+1];
//				//select rowTuple => colTuple
//				for (int row=0; row<noOfEquations; row++) {
//					ArrayList<String> rowTuple = allTupleValue.get(row); 
//					//get colTuple
//					for (int column=0; column<noOfEquations; column++) {
//						ArrayList<String> colTuple = allTupleValue.get(column);
//						double transProb = 1;
//						for (int randIndex=0; randIndex < randVarLabel.size(); randIndex++) {
//							String randVar = randVarLabel.get(randIndex);
//							transProb = transProb * transitionFunctionMap.get(randVar).
//									getProbByValue(rowTuple.get(randIndex),
//													colTuple.get(randIndex));
//						}
//						
//						
//						if (row == column)
//							coefficients[row][column] = 1 - discountFactor*transProb;
//						else
//							coefficients[row][column] = -discountFactor*transProb;
//						
//					}
//					//set utility
//					coefficients[row][noOfEquations] = getUtilityFromTableGivenDecAndRand(tableWithRandom, decValueList, rowTuple);
//				}
//				
////				System.out.println(Arrays.deepToString(coefficients));
//				ArrayList<Double> utilityList = gaussian(coefficients, noOfEquations);
//				
////				if (idStr.equals("0")) System.out.println(utilityList);
//				//create new row with a fix dec values, but different rand values
//				int i = 0;
//				for (ArrayList<String> randValueToBeAddedList:allTupleValue) {
//					Row newRow = new Row(decValueList, randValueToBeAddedList, utilityList.get(i));
//					i++;
//					newlyCreatedTable.addRow(newRow);
//				}
//			//end if: decValueList not contained
//			}
//		//end while: traversing table 
//		}
//		return newlyCreatedTable;
//	}
	
	boolean isArrayContainedInOtherArray(ArrayList<ArrayList<String>> bigArray, ArrayList<String> smallArray) {
		if (bigArray.size() == 0 || smallArray.size() == 0)
			return false;
		for (ArrayList<String> traversal:bigArray) {
			boolean isArrayFound = true;
			if (traversal.size() != smallArray.size()) {
				System.out.println("!!!!!!Different size!!!!!!");
				continue;
			}
			for (int i=0; i<traversal.size(); i++) {
				if (traversal.get(i).equals(smallArray.get(i)) == false) {
					isArrayFound = false;
					break;
				}
					
			}
			if (isArrayFound == false)	continue;
			return true;
		}
		
		return false;
	}

	double getUtilityFromTableGivenDecAndRand(Table table, ArrayList<Double> decValueList, ArrayList<Double> randIterationValue) {
		ArrayList<Row> tableToTraversed = table.getTable();
		for (Row row:tableToTraversed) {
			boolean isRowFound = true;
			//System.err.println("Utility of this row " + row.getUtility());
			ArrayList<Double> rowValueList = row.getValueList();
			ArrayList<Double> rowRandomList= row.getRandomList();

			if (rowValueList.size() != decValueList.size() || rowRandomList.size() != randIterationValue.size()) {
				System.err.println("!!!!!!Different size!!!!!!!!!");
				System.err.println("!!!!!!Recheck your code!!!!!!");
			}
			for (int index=0; index<decValueList.size(); index++) {
				if (rowValueList.get(index).equals(decValueList.get(index)) == false) {
					isRowFound = false;
					break;
				}
			}
			
			if (isRowFound == false)	continue;
			
			for (int index=0; index<randIterationValue.size(); index++) {
				if (rowRandomList.get(index).equals(randIterationValue.get(index)) == false) {
					isRowFound = false;
					break;
				}
			}
			
			if (isRowFound == false)	continue;
			
			return row.getUtility();
		}
		System.out.println("Not found!!!!!!!!!!!!!!");
		return Integer.MIN_VALUE;
	}

	public ArrayList<Double> gaussian(double arr[][], int N) {
		ArrayList<Double> longtermUtilityList = new ArrayList<Double>();
		// take each line as pivot, except for the last line
		for (int pivotIndex = 0; pivotIndex < N - 1; pivotIndex++) {
			// go from the line below line pivotIndex, to the last line
			boolean isNotZeroRowFound = false;
			if (arr[pivotIndex][pivotIndex] == 0) {
				int notZeroRow;
				for (notZeroRow = pivotIndex + 1; notZeroRow < N; notZeroRow++) {
					if (arr[notZeroRow][pivotIndex] != 0) {
						isNotZeroRowFound = true;
						break;
					}
				}

				if (isNotZeroRowFound) {
					// swap row pivotIndex and row notZeroRow
					for (int columnToSwapIndex = 0; columnToSwapIndex < N + 1; columnToSwapIndex++) {
						double tempForSwap = arr[pivotIndex][columnToSwapIndex];
						arr[pivotIndex][columnToSwapIndex] = arr[notZeroRow][columnToSwapIndex];
						arr[notZeroRow][columnToSwapIndex] = tempForSwap;
					}
				} else {
					continue;
				}
			}

			for (int rowForGauss = pivotIndex + 1; rowForGauss < N; rowForGauss++) {
				double factor = arr[rowForGauss][pivotIndex]
						/ arr[pivotIndex][pivotIndex];
				for (int columnForGauss = 0; columnForGauss < N + 1; columnForGauss++) {
					arr[rowForGauss][columnForGauss] = arr[rowForGauss][columnForGauss]
							- factor * arr[pivotIndex][columnForGauss];
				}
			}
		}

		for (int columnPivot = N - 1; columnPivot >= 1; columnPivot--) {
			for (int rowAbovePivot = columnPivot - 1; rowAbovePivot >= 0; rowAbovePivot--) {
				double fraction = arr[rowAbovePivot][columnPivot]
						/ arr[columnPivot][columnPivot];
				for (int columnInTheRow = 0; columnInTheRow < N + 1; columnInTheRow++)
					arr[rowAbovePivot][columnInTheRow] = arr[rowAbovePivot][columnInTheRow]
							- fraction * arr[columnPivot][columnInTheRow];
			}
		}
		
		for (int i=0; i<N; i++) { 
			longtermUtilityList.add(arr[i][N]/arr[i][i]); 
		}
		
		return longtermUtilityList;

	}
		
	public void sendObjectMessage(AID receiver, Object content, int msgCode) {
		ACLMessage message = new ACLMessage(msgCode);
		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		send(message);
	}
	
	public void sendObjectMessageWithTime(AID receiver, Object content, int msgCode, long time) {
		ACLMessage message = new ACLMessage(msgCode);
		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		message.setLanguage(String.valueOf(time));
		send(message);
	}


	public void printTree(boolean isRoot) {
		System.out.println("************");
		System.out.println("My ID is: " + idStr);
		if (isRoot == false)
			System.out.println("My parent is: " + parentAID.getLocalName());
		System.out.println("My children are: ");
		for (int i=0;i<childrenAIDList.size();i++) {
			System.out.print(childrenAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();
		
		System.out.println("My pseudo_parents are: ");
		for (int i=0;i<pseudoParentAIDList.size();i++) {
			System.out.print(pseudoParentAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();
		
		System.out.println("My pseudo_children are: ");
		for (int i=0;i<pseudoChildrenAIDList.size();i++) {
			System.out.print(pseudoChildrenAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();
		
	}
	
	public void readMinizincFileThenParseNeighborAndConstraintTable(String inputFileName) {
		final String DOMAIN = "domain";
		final String FUNCTION = "function";
		
		try (BufferedReader br = new BufferedReader(new FileReader(
				System.getProperty("user.dir") + '/' + inputFileName))) {
			ArrayList<String> lineWithSemiColonList = new ArrayList<String>();
			
			String line = br.readLine();
			while (line != null) {
				if (line.length() == 0 || line.startsWith("%") == true) {
					line = br.readLine();
					continue;
				}
				
				//concatenate line until meet ';'
				if (line.endsWith(";") == false) {
					do {
						line += br.readLine();
					} while (line.endsWith(";") == false);
				}
				
//				line = line.replace(" ","");
				line = line.replace(";","");
				lineWithSemiColonList.add(line);
				line = br.readLine();
			}
			
			//Process line by line;
			for (String lineWithSemiColon:lineWithSemiColonList) {
				/**DECISION_VARIABLE*/
				//read decision variable domain
			    //domain 10
				if (lineWithSemiColon.contains(DOMAIN)) {
				    lineWithSemiColon = lineWithSemiColon.replaceAll("domain ", "");
				    domainMax = Integer.parseInt(lineWithSemiColon);
				    globalInterval = new Interval(-domainMax, domainMax);
				}
				/**FUNCTION*/
				//function -281v_2^2 199v_2 -22v_0^2 252v_0 288v_2v_0 358;
				//BinaryFunction func = new BinaryFunction(-1, 20, -3, 40, -2, 6, Double.valueOf(idStr), 1.0);

				if (lineWithSemiColon.contains(FUNCTION)) {
				    String selfVar = "v_" + idStr;
				    if (!lineWithSemiColon.contains(selfVar)) continue;
	                System.out.println("Agent " + idStr + " line " + lineWithSemiColon);
				    
				    lineWithSemiColon = lineWithSemiColon.replaceAll("function ", "");
				    String coeffString[] = lineWithSemiColon.split(" ");
				    int arr[] = parseFunction(coeffString, selfVar);
				    BinaryFunction func = new BinaryFunction(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5],
				                              idStr, String.valueOf(arr[6]));
				    func.setSelfInterval(globalInterval);
                    func.setOtherInterval(globalInterval);
                    PiecewiseFunction pwFunc = new PiecewiseFunction(idStr, String.valueOf(arr[6]));
                    pwFunc.addNewFunction(func);
                    functionList.add(pwFunc);

				    System.out.println("Agent " + idStr + " function " + pwFunc);
				}
			}
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
	
    //function -281v_2^2 199v_2 -22v_0^2 252v_0 288v_2v_0 358;
	public int[] parseFunction(String[] line, String selfAgent) {
	    int coeffArray[] = new int [7];
	    for (String str : line) {
	        //v_1^2 or v1 or v2  
	        if (str.contains(selfAgent)) {
	            str = str.replace(selfAgent, "");
 	            if (str.contains("^2")) {
 	               coeffArray[0] = Integer.parseInt(str.replace("^2", ""));
 	            }
 	            else if (!str.contains("v_")) {
 	               coeffArray[1] = Integer.parseInt(str);
 	            }
 	            else if (str.contains("v_")) {
 	               coeffArray[4] = Integer.parseInt(str.split("v_")[0]);
                   coeffArray[6] = Integer.parseInt(str.split("v_")[1]);
                   String neighbor = String.valueOf(coeffArray[6]);
                   if (!neighborStrList.contains(neighbor)) neighborStrList.add(neighbor);
 	            }
	        }
	        else {
               if (str.contains("^2")) {   
                   coeffArray[2] = Integer.parseInt(str.split("v_")[0]);
               }
               else if (str.contains("v_")) {
                   coeffArray[3] = Integer.parseInt(str.split("v_")[0]);
               }
               else {
                   coeffArray[5] = Integer.parseInt(str);
               }
	        }
	    }
	    
	    return coeffArray;
	}
	
	public void registerWithDF () {
		DFAgentDescription dfd = new DFAgentDescription();
		dfd.setName(getAID());
		for (int i=0; i<neighborStrList.size(); i++) {
			ServiceDescription sd = new ServiceDescription();
			sd.setType(neighborStrList.get(i));
			sd.setName(idStr);
			dfd.addServices(sd);
		}
		try {
			DFService.register(this, dfd);
		}
		catch (FIPAException fe) {
			fe.printStackTrace();
		}
	}
	
	//get utility with parents, pseudoparents
	//then add its switching cost
//	public double utilityWithParentAndPseudoAndUnary() {
//		double sumUtility = 0;
//
////		for (int ts=0; ts<=h; ts++) {
//			ArrayList<Table> tableList = constraintTableAtEachTSMap.get(0);
//	    	for (Table constraintTable:tableList) {
//				ArrayList<String> decVarList = constraintTable.getDecVarLabel();
//				ArrayList<String> decValueList = new ArrayList<String>();
//				
//				//chi gui với constraint voi parent and pseudoparents
//				boolean notInParentList = false;
//				for (String var:decVarList) {
//					if (var.equals(idStr))
//						continue;
//					if (parentAndPseudoStrList.contains(var) == false) {
//						notInParentList = true;
//						break;
//					}
//				}
//				
//				if (notInParentList)
//					continue;
//				
//				for (String agentInList:decVarList) {
//					if (agentInList.equals(idStr))
//						decValueList.add(valueAtEachTSMap.get(0));
//					else
//						decValueList.add(agentView_DPOP_TSMap.get(agentInList).get(0));
//				}
//				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
//			}
////		}
//		return sumUtility;
//	}
	
//	public double calculcatingSwitchingCost() {
//		double sC = 0;
//		if (getValueAtEachTSMap().size() == 1) return 0;
//		for (int i=1; i<getValueAtEachTSMap().size(); i++) {
////			if (getValueAtEachTSMap().get(i).equals(getValueAtEachTSMap().get(i-1)) == false)
////				sC += switchingCost;
//			
//			sC += sc_func(getValueAtEachTSMap().get(i), getValueAtEachTSMap().get(i-1));
//		}
//		return sC;
//	}

	public String getIdStr() {
		return idStr;
	}

	public void setIdStr(String idStr) {
		this.idStr = idStr;
	}

	public boolean isRoot() {
		return isRoot;
	}

	public void setRoot(boolean isRoot) {
		this.isRoot = isRoot;
	}

	public boolean isLeaf() {
		return isLeaf;
	}

	public void setLeaf(boolean isLeaf) {
		this.isLeaf = isLeaf;
	}

	public List<AID> getNeighborAIDList() {
		return neighborAIDList;
	}

	public void setNeighborAIDList(ArrayList<AID> neighborAIDList) {
		this.neighborAIDList = neighborAIDList;
	}

	public List<String> getNeighborStrList() {
		return neighborStrList;
	}

	public void setNeighborStrList(ArrayList<String> neighborStrList) {
		this.neighborStrList = neighborStrList;
	}

	public HashMap<AID, Integer> getConstraintInfoMap() {
		return constraintInfoMap;
	}

	public void setConstraintInfoMap(HashMap<AID, Integer> constraintInfoMap) {
		this.constraintInfoMap = constraintInfoMap;
	}

	public boolean isNotVisited() {
		return notVisited;
	}

	public void setNotVisited(boolean notVisited) {
		this.notVisited = notVisited;
	}

	public List<AID> getChildrenAIDList() {
		return childrenAIDList;
	}

	public void setChildrenAIDList(List<AID> childrenAIDList) {
		this.childrenAIDList = childrenAIDList;
	}

	public AID getParentAID() {
		return parentAID;
	}

	public void setParentAID(AID parentAID) {
		this.parentAID = parentAID;
	}

	public List<String> getParentAndPseudoStrList() {
		return parentAndPseudoStrList;
	}

	public void setParentAndPseudoStrList(List<String> parentAndPseudoStrList) {
		this.parentAndPseudoStrList = parentAndPseudoStrList;
	}

	public List<AID> getPseudoChildrenAIDList() {
		return pseudoChildrenAIDList;
	}

	public void setPseudoChildrenAIDList(List<AID> pseudoChildrenAIDList) {
		this.pseudoChildrenAIDList = pseudoChildrenAIDList;
	}

	public List<AID> getPseudoParentAIDList() {
		return pseudoParentAIDList;
	}

	public void setPseudoParentAIDList(List<AID> pseudoParentAIDList) {
		this.pseudoParentAIDList = pseudoParentAIDList;
	}

	public ThreadMXBean getBean() {
		return bean;
	}

	public void setBean(ThreadMXBean bean) {
		this.bean = bean;
	}

	public long getCurrentStartTime() {
		return currentStartTime;
	}

	public void setCurrentStartTime(long currentStartTime) {
		this.currentStartTime = currentStartTime;
	}

	public HashMap<String, ArrayList<String>> getDecisionVariableDomainMap() {
		return decisionVariableDomainMap;
	}

	public void setDecisionVariableDomainMap(
			HashMap<String, ArrayList<String>> decisionVariableDomainMap) {
		this.decisionVariableDomainMap = decisionVariableDomainMap;
	}

	public HashMap<Integer, Double> getValueAtEachTSMap() {
		return valueAtEachTSMap;
	}

	public void setValueAtEachTSMap(HashMap<Integer, Double> valueAtEachTSMap) {
		this.valueAtEachTSMap = valueAtEachTSMap;
	}

	public long getSimulatedTime() {
		return simulatedTime;
	}

	public void setSimulatedTime(long simulatedTime) {
		this.simulatedTime = simulatedTime;
	}
	
	public void addupSimulatedTime(long time) {
		this.simulatedTime += time;
	}

	public List<Table> getCurrentTableListDPOP() {
		return currentTableListDPOP;
	}

	public void setCurrentTableListDPOP(ArrayList<Table> currentTableListDPOP) {
		this.currentTableListDPOP = currentTableListDPOP;
	}

	public HashMap<Integer, ArrayList<Table>> getConstraintTableAtEachTSMap() {
		return constraintTableAtEachTSMap;
	}

	public void setConstraintTableAtEachTSMap(
			HashMap<Integer, ArrayList<Table>> constraintTableAtEachTSMap) {
		this.constraintTableAtEachTSMap = constraintTableAtEachTSMap;
	}

	public Table getCollapsedSwitchingCostTable() {
		return collapsedSwitchingCostTable;
	}

	public void setCollapsedSwitchingCostTable(Table collapsedSwitchingCostTable) {
		this.collapsedSwitchingCostTable = collapsedSwitchingCostTable;
	}

	public int getCurrentTS() {
		return currentTS;
	}

	public void setCurrentTS(int currentTS) {
		this.currentTS = currentTS;
	}
	
	public void incrementCurrentTS() {
		this.currentTS++;
	}

	public Table getAgentViewTable() {
		return agentViewTable;
	}

	public void setAgentViewTable(Table agentViewTable) {
		this.agentViewTable = agentViewTable;
	}

	public double getChosenValue() {
		return chosenValue;
	}

	public void setChosenValue(double chosenValue) {
		this.chosenValue = chosenValue;
	}

	public ArrayList<Double> getCurrentGlobalUtilityList() {
		return currentGlobalUtilityList;
	}

	public void setCurrentGlobalUtilityList(
			ArrayList<Double> currentGlobalUtilityList) {
		this.currentGlobalUtilityList = currentGlobalUtilityList;
	}

	public double getCurrentGlobalUtility() {
		return currentGlobalUtility;
	}

	public void setCurrentGlobalUtility(double currentGlobalUtility) {
		this.currentGlobalUtility = currentGlobalUtility;
	}

	public double getTotalGlobalUtility() {
		return totalGlobalUtility;
	}

	public void setTotalGlobalUtility(double totalGlobalUtility) {
		this.totalGlobalUtility = totalGlobalUtility;
	}

	public static long getDelayMessageTime() {
		return delayMessageTime;
	}

	public static void setDelayMessageTime(long delayMessageTime) {
		DCOP.delayMessageTime = delayMessageTime;
	}

	public double getUtilFromChildrenLS() {
		return utilFromChildrenLS;
	}

	public void setUtilFromChildrenLS(double utilFromChildrenLS) {
		this.utilFromChildrenLS = utilFromChildrenLS;
	}
	
	public void addtoUtilFromChildrenLS(double util) {
		this.utilFromChildrenLS += util;
	}

	public Map<String, ArrayList<Double>> getAgentView_DPOP_TSMap() {
		return agentView_DPOP_TSMap;
	}

	public void setAgentView_DPOP_TSMap(
			Map<String, ArrayList<Double>> agentView_DPOP_TSMap) {
		this.agentView_DPOP_TSMap = agentView_DPOP_TSMap;
	}

	public long getEndTime() {
		return endTime;
	}

	public void setEndTime(long endTime) {
		this.endTime = endTime;
	}

	public long getStartTime() {
		return startTime;
	}

	public void setStartTime(long startTime) {
		this.startTime = startTime;
	}

	public int getLsIteration() {
		return lsIteration;
	}

	public void setLsIteration(int lsIteration) {
		this.lsIteration = lsIteration;
	}
	
	public void incrementLsIteration() {
		this.lsIteration++;
	}

	public ArrayList<String> getBestImproveValueList() {
		return bestImproveValueList;
	}

	public void setBestImproveValueList(ArrayList<String> bestImproveValueList) {
		this.bestImproveValueList = bestImproveValueList;
	}

	public double getOldLSUtility() {
		return oldLSUtility;
	}

	public void setOldLSUtility(double oldLSUtility) {
		this.oldLSUtility = oldLSUtility;
	}
	
	public boolean isStop() {
		return stop;
	}

	public void setStop(boolean stop) {
		this.stop = stop;
	}
	
	public double getOldLSRunningTime() {
		return oldLSRunningTime;
	}

	public void setOldLSRunningTime(double oldLSRunningTime) {
		this.oldLSRunningTime = oldLSRunningTime;
	}
	
	public double getUtilityAndCost() {
		return utilityAndCost;
	}

	public void setUtilityAndCost(double utilityAndCost) {
		this.utilityAndCost = utilityAndCost;
	}
	
	public HashMap<String, Double> getValuesToSendInVALUEPhase() {
		return valuesToSendInVALUEPhase;
	}

	public void setValuesToSendInVALUEPhase(
			HashMap<String, Double> valuesToSendInVALUEPhase) {
		this.valuesToSendInVALUEPhase = valuesToSendInVALUEPhase;
	}
	
	public void addValuesToSendInValuePhase(String agent, Double value) {
		this.valuesToSendInVALUEPhase.put(agent, value);
	}
	
	public HashMap<Integer, String> getPickedRandomMap() {
		return pickedRandomMap;
	}

	public void setPickedRandomMap(HashMap<Integer, String> pickedRandomMap) {
		this.pickedRandomMap = pickedRandomMap;
	}
	
	public void addPickedRandomMap(Integer timeStep, String pickedRandomValue) {
		this.pickedRandomMap.put(timeStep, pickedRandomValue);
	}
	
	public String getPickedRandomAt(Integer timeStep) {
		return this.pickedRandomMap.get(timeStep);
	}
	
    public long getCurrentUTILstartTime() {
		return currentUTILstartTime;
	}

	public void setCurrentUTILstartTime(long currentUTILstartTime) {
		this.currentUTILstartTime = currentUTILstartTime;
	}
	
	public String getLastLine() {
		return lastLine;
	}

	public void setLastLine(String lastLine) {
		this.lastLine = lastLine;
	}

    public Map<String, ArrayList<Double>> getBestValueMap() {
		return bestValueMap;
	}

	public void setBestValueMap(Map<String, ArrayList<Double>> bestValueMap) {
		this.bestValueMap = bestValueMap;
	}
	
	public double[] toArray(ArrayList<Double> arrayList) {
		int arrSize = arrayList.size();
		double[] convertedArray = new double[arrSize];
		for (int i=0; i<arrSize; i++) {
			convertedArray[i] = arrayList.get(i);
		}
		return convertedArray;
	}
	
	public static double[] multiply(double[] vector, TransitionFunction transFunc) {
		int size = vector.length;
		if (size != transFunc.getSize()) {
			System.err.println("Not a square matrix");
			return null;
		}
		
		double resultVector[] = new double[size];
		for (int col=0; col<size; col++) {
			for (int k=0; k<size; k++) {
				resultVector[col] += vector[k] * transFunc.getProbByIndex(k,col);
			}
		}
		
		return resultVector;
	}
	
	public boolean isNextAgent(String agentLocalName) {
		if (Integer.valueOf(idStr) % 3 + 1 == Integer.valueOf(agentLocalName))
			return true;
		
		return false;
	}
			
	public Row randomChoose(Table table, double reponseTime) {
		double chosenProcessLoad = -Double.MAX_VALUE;
		Random rand = new Random();
		Row chosenRow = null;
//		System.out.println("=========SIZE " + table.getLoadMap().keySet().size());
		int size = table.getRowListFromKey(reponseTime).size();
		do {
			int random = rand.nextInt(size);
			chosenRow = table.getRowListFromKey(reponseTime).get(random);
			chosenProcessLoad = chosenRow.getValueList().get(4);
		}
		while (chosenProcessLoad != reponseTime);
				
		return chosenRow;
		
	}

    public List<PiecewiseFunction> getFunctionList() {
        return functionList;
    }

    public void setFunctionList(List<PiecewiseFunction> functionList) {
        this.functionList = functionList;
    }

    public PiecewiseFunction getAgentViewFunction() {
        return agentViewFunction;
    }

    public void setAgentViewFunction(PiecewiseFunction agentViewFunction) {
        this.agentViewFunction = agentViewFunction;
    }

    public List<PiecewiseFunction> getCurrentFunctionListDPOP() {
        return currentFunctionListDPOP;
    }

    public void setCurrentFunctionListDPOP(List<PiecewiseFunction> currentFunctionListDPOP) {
        this.currentFunctionListDPOP = currentFunctionListDPOP;
    }
}	
