package agent; //dcop

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.Serializable;
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadMXBean;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;

import behaviour.AGENT_TERMINATE;
import behaviour.BROADCAST_RECEIVE_HEURISTIC_INFO;
import behaviour.DPOP_UTIL;
import behaviour.DPOP_VALUE;
import behaviour.LS_RECEIVE_SEND_LS_UTIL;
import behaviour.MESSAGE_TYPE;
import behaviour.INIT_PROPAGATE_DPOP_VALUE;
import behaviour.PSEUDOTREE_GENERATION;
import behaviour.RAND_PICK_VALUE;
import behaviour.INIT_RECEIVE_DPOP_VALUE;
import behaviour.RECEIVE_IMPROVE;
import behaviour.INIT_RECEIVE_SEND_LS_UTIL;
import behaviour.RECEIVE_VALUE;
import behaviour.SEARCH_NEIGHBORS;
import behaviour.SEND_IMPROVE;
import table.Row;
import table.Table;
import transition.TransitionFunction;
import jade.core.AID;
import jade.core.Agent;
import jade.core.behaviours.ParallelBehaviour;
import jade.core.behaviours.SequentialBehaviour;
import jade.domain.DFService;
import jade.domain.FIPAException;
import jade.domain.FIPAAgentManagement.DFAgentDescription;
import jade.domain.FIPAAgentManagement.ServiceDescription;
import jade.lang.acl.ACLMessage;

/* Each agent is a node in the graph
 * The graph is presented as pseudo-tree
 * Pseudo-tree is generated by Distributed DFS
 * 
 * Each Agent has a "root" flag to indicate root or not
 * Each Agent has a local name which is an ID number and is assigned by constructor.
 * Based on the ID number, each agent has a fixed number neighbors, which is instantiated
 * by the constructor
 * 
 * ****PROCESS OF FINDING AID NEIGHBORS
 * Each Agent has a list of neighbors, and register his neighbors ID number to DF
 * Each Agent find his neighbors' AIDs by searching DF which agents register the Agent's ID numbers as
 * a neighbor. The add to his list of AID neighbors.
 * 
 * The process of finding AIDs only stops when the number of recognized AID is the number of his neighbors
 * 
 * ****PROCESS OF GENERATING PSEUDOTREE
 * Each agent always listens to the first messages, while trying to finish the searching process
 * After finishing the searching process, he begins to process the messages and send the message to his
 * neighbors.
 * 
 * Agent root start sending messages when finish searching agents.
 * 
 * Each agents will print out his parent, his children, his pseudo-parents, his pseudo-children
 * 
 * ****PROCESS OF DPOP
 * DPOP starts when the PSEUDOTREE PROCESS FINISHED
 */
public class DCOP extends Agent implements DCOP_INFO {
	
	private static final long serialVersionUID = 2919994686894853596L;
	
    public int algorithm;
    public int h;   //timeStep where the Markov chain is converged
    public double switchingCost;
    public String inputFileName;
	public int hybridTS;
	public int scExponentialBase = 2;
	public int scType;
	public int instanceD;
	public String varDecisionFileName;

	private String idStr;
	private boolean isRoot;
	private boolean isLeaf;
	
	private AID	parentAID;
	private ArrayList<AID> childrenAIDList;
	private ArrayList<AID> neighborAIDList; 
	private ArrayList<AID> pseudoParentAIDList;
	private ArrayList<AID> pseudoChildrenAIDList;
	private ArrayList<String> parentAndPseudoStrList;
	private ArrayList<String> neighborStrList;

	
	private ArrayList<Table> currentTableListDPOP;
	private ArrayList<Table> constraintTableWithoutRandomList;
	private ArrayList<Table> constraintTableWithRandomList;
	private ArrayList<Table> organizedConstraintTableList;
	private ArrayList<Table> organizedConstraintTableWithRandomList;
	
	private ArrayList<String> decisionVariableList;
	private ArrayList<String> randomVariableList;
	private HashMap<String, ArrayList<String>> decisionVariableDomainMap;
	private HashMap<String, ArrayList<String>> randomVariableDomainMap;
	//map TS -> constraint table list (if local_search)
	//map TS -> 1 collapsed table list (if collapsed dpop)
	private HashMap<Integer, ArrayList<Table>> constraintTableAtEachTSMap;
	private HashMap<String, double[][]> probabilityAtEachTimeStepMap;
	private Table collapsedSwitchingCostTable;
	
	//VALUE phase
	HashMap<String, String> valuesToSendInVALUEPhase;
	
	//used for LOCAL SEARCH
	private HashMap<Integer, String> valueAtEachTSMap;
	//ArrayList<Double> utilityAtEachTSList;
	//agent -> <values0, values1, ..., values_n>
    private HashMap<String, HashMap<Integer, String>> agentView_DPOP_TSMap;
    private ArrayList<Double> currentGlobalUtilityList;
    private ArrayList<String> bestImproveValueList;
    private ArrayList<Double> bestUtilityList;
    private ArrayList<Double> bestImproveUtilityList;
    private double currentGlobalUtility;
    private double totalGlobalUtility;
    private double utilFromChildrenLS;
		
    private HashMap<String, ArrayList<Double>> initProabilityMap;
    private HashMap<String, TransitionFunction> transitionFunctionMap;
    private Table agentViewTable;
    private String chosenValue;
    private HashMap<Integer, String> pickedRandomMap;

	private int currentTS;
	
    private long startTime;
    private long endTime;
    private long currentUTILstartTime;
	private int lsIteration;

	//simulated time
	private ThreadMXBean bean;
    private long simulatedTime = 0;
    private long currentStartTime;
    private static long delayMessageTime = 0;
    
    //for reuse information
    private HashMap<AID, Integer> constraintInfoMap;
    private boolean notVisited = true;
	
//	ArrayList<String> neighborWithRandList;
	
    //for writing file
    private double oldLSUtility = 0;
	private double oldLSRunningTime = 0; //old running time because compare to see if old iteration is converged
	private boolean stop = false;
	public int noAgent;
	private double utilityAndCost;
	private String lastLine;

	public DCOP() {
		initializeArguments();
		isRoot = false;
		isLeaf = false;
		totalGlobalUtility = 0;
		lsIteration = 0;
		utilFromChildrenLS = 0;
		currentTS = 0;
	}
	
	//done with LS-RAND
	public void readArguments() {
    	Object[] args = getArguments();
		//parameters for running experiments
		algorithm = 			Integer.valueOf((String) args[0]);
		inputFileName = 		(String) args[1]; 					//rep_10_d14.dzn
		h = 					Integer.valueOf((String) args[2]);
		switchingCost = 		Integer.valueOf((String) args[3]);
		String a[] = inputFileName.replaceAll("rep_","").replaceAll(".dzn","").split("_d");
		instanceD = Integer.valueOf(a[0]);
		noAgent = Integer.valueOf(a[1]);
		idStr = getLocalName();	
		scType = DCOP.EXP_3;
		
		//can be done after getting the algorithm
		if (algorithm == C_DPOP) {
//			constraintTableAtEachTSMap.put(0, new ArrayList<Table>());
		}
		else
			//SDPOP, LS_SDPOP, FORWARD, BACKWARD, HYBRID, REACTIVE, LS_RAND
			for (int tS=0; tS<=h; tS++) {
				constraintTableAtEachTSMap.put(tS, new ArrayList<Table>());
			}
		
		varDecisionFileName = DCOP.algTypes[algorithm] + "_d=" + noAgent
													+ "_sw=" + (int) switchingCost
													+ "_h=" + h + ".txt";  
	}
	
    protected void setup() {
    	readArguments();
		if (idStr.equals("1")) {
			System.out.println("alg " + algorithm);
			System.out.println("iter " + MAX_ITERATION);
			System.out.println("input " + inputFileName);
			System.out.println("ts " + h);
			System.out.println("id " + instanceD);
		}

		readMinizincFileThenParseNeighborAndConstraintTable(inputFileName);
		if (idStr.equals("1"))
			isRoot = true;
		
		/***** START register neighbors with DF *****/ 
		registerWithDF();
		/***** END register neighbors with DF *****/ 

		probabilityAtEachTimeStepMap.put(idStr, new double[h+1][domainSize]);
		
		//create actual distribution based on previous observation
		//REACT sample random values in DPOP_UTIL step
		//HYRBID sample random values on the way
		if (algorithm == HYBRID) {
			for (int i=0; i<=h; i++) {
				addPickedRandomMap(i, simulateRandom(i));
				createProbabilityWithObservation(i);
			}
		}
		//create distribution at each time step, and stationary distribution at h
		else if (algorithm == FORWARD || algorithm == BACKWARD || algorithm == LS_SDPOP ||
			     algorithm == LS_RAND ) {
			//create actual distribution from 0 -> h-1
			for (int i=0; i<=h-1; i++) {
				createProbabilityAt(i);
			}
			//create stable distribution for time step h
			createStableProbabilityForLastTimeStep();
		}
		//PD-DCOP algorithms, no need to consider stationary distribution
		else if (algorithm != REACT) {
			for (int i=0; i<=h; i++) {
				createProbabilityAt(i);
			}
		}
		
		reorganizeRandomTable();
		reorganizeConstaintTable();
		//different from different algorithms
		//initialize the tableMap
		
		if (algorithm == LS_RAND)
			for (int ts=0; ts<=h; ts++) {
				addExpectedRandomTableToList(ts);
				addConstraintTableToList(ts);
			}
		
//		if (algorithm == C_DPOP) {
//			addExpectedRandomTableToListAllTS();
//			addConstraintTableToListAllTS();
//		}		

		startTime = System.currentTimeMillis();
		bean = ManagementFactory.getThreadMXBean();
		bean.setThreadContentionMonitoringEnabled(true);
		
		SequentialBehaviour mainSequentialBehaviourList = new SequentialBehaviour();
		mainSequentialBehaviourList.addSubBehaviour(new SEARCH_NEIGHBORS(this));
		mainSequentialBehaviourList.addSubBehaviour(new BROADCAST_RECEIVE_HEURISTIC_INFO(this));
		mainSequentialBehaviourList.addSubBehaviour(new PSEUDOTREE_GENERATION(this));
		
		//run DPOP multi-step
		if (algorithm == C_DPOP) {
			mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this));
			mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this));
		}
		
		//correct
		if (algorithm == FORWARD || algorithm == BACKWARD ||
			algorithm == LS_SDPOP     || algorithm == REACT || algorithm == HYBRID) {
			for (int i=0; i<=h; i++) {
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_UTIL(this));
				mainSequentialBehaviourList.addSubBehaviour(new DPOP_VALUE(this));
			}
		}
		
		/*** LOCAL SEARCH ***/
		//pick values randomly
		if (algorithm == LS_RAND) {
			mainSequentialBehaviourList.addSubBehaviour(new RAND_PICK_VALUE(this));
		}
		
		//sending and receiving values from neighbors
		if (algorithm == LS_SDPOP || algorithm == LS_RAND) {
			mainSequentialBehaviourList.addSubBehaviour(new INIT_PROPAGATE_DPOP_VALUE(this));
			mainSequentialBehaviourList.addSubBehaviour(new INIT_RECEIVE_DPOP_VALUE(this));
			mainSequentialBehaviourList.addSubBehaviour(new INIT_RECEIVE_SEND_LS_UTIL(this));
		}
		
		if (algorithm == LS_SDPOP || algorithm == LS_RAND) {
			mainSequentialBehaviourList.addSubBehaviour(new SEND_IMPROVE(this));
			ParallelBehaviour localSearch = new ParallelBehaviour(); 
			localSearch.addSubBehaviour(new RECEIVE_IMPROVE(this));
			localSearch.addSubBehaviour(new RECEIVE_VALUE(this));
			localSearch.addSubBehaviour(new LS_RECEIVE_SEND_LS_UTIL(this));
			mainSequentialBehaviourList.addSubBehaviour(localSearch);
		}
		
		mainSequentialBehaviourList.addSubBehaviour(new AGENT_TERMINATE(this));
		addBehaviour(mainSequentialBehaviourList); 
	}
	
	//JADE function: stop the Agent
	protected void takeDown() {	
		endTime = System.currentTimeMillis();
		System.out.println("Agent " + idStr + " has RUNNING TIME: " + (endTime - startTime) + "ms");
		System.out.println("Agent " + idStr + " with threadID " + Thread.currentThread().getId() + 
								" has SIMULATED TIME: " + simulatedTime/1000000 + "ms");
		System.out.println("Agent " + idStr + " with threadID " + Thread.currentThread().getId() + 
				" has sim TIME: " + bean.getCurrentThreadUserTime()/1000000 + "ms");
		System.err.println("Agent: " + getAID().getName() + " terminated.");
		try {
			DFService.deregister(this);
		} catch (FIPAException e) {
			e.printStackTrace();
		}
	}

	public void initializeArguments() {
		neighborStrList = new ArrayList<String>();
		neighborAIDList = new ArrayList<AID>();
		childrenAIDList = new ArrayList<AID>();
		pseudoParentAIDList = new ArrayList<AID>();
		pseudoChildrenAIDList = new ArrayList<AID>();
		parentAndPseudoStrList = new ArrayList<String>();
		currentTableListDPOP = new ArrayList<Table>();
		constraintTableWithoutRandomList = new ArrayList<Table>();
		constraintTableWithRandomList = new ArrayList<Table>();
		organizedConstraintTableList = new ArrayList<Table>();
		organizedConstraintTableWithRandomList = new ArrayList<Table>();
		decisionVariableList = new ArrayList<String>();
		decisionVariableDomainMap = new HashMap<String, ArrayList<String>>();
		randomVariableList = new ArrayList<String>();
		randomVariableDomainMap = new HashMap<String, ArrayList<String>>();
		initProabilityMap = new HashMap<String, ArrayList<Double>>();
		transitionFunctionMap = new HashMap<String, TransitionFunction>();
		probabilityAtEachTimeStepMap = new HashMap<String, double[][]>();
		constraintTableAtEachTSMap = new HashMap<Integer, ArrayList<Table>>();
		valueAtEachTSMap = new HashMap<Integer, String>();
		agentView_DPOP_TSMap = new HashMap<String, HashMap<Integer, String>>();
		currentGlobalUtilityList = new ArrayList<Double>();
		bestImproveValueList = new ArrayList<String>();
		bestUtilityList = new ArrayList<Double>();
		bestImproveUtilityList = new ArrayList<Double>();
		constraintInfoMap = new HashMap<AID, Integer>();
		valuesToSendInVALUEPhase = new HashMap<String, String>();
		pickedRandomMap = new HashMap<Integer, String>();
		lastLine = "";
	}
	
	public void sendImprove() {
		currentStartTime = bean.getCurrentThreadUserTime();
		
		ArrayList<Double> currentUtilityList = utilityMinusCostOverTS(valueAtEachTSMap);

		double maxUtility = Integer.MIN_VALUE;

		ArrayList<String> domain = decisionVariableDomainMap.get(idStr);
		int domainSize = domain.size();
		int totalSize = (int) Math.pow(domainSize, h + 1);
		
		for (int index = 0; index < totalSize; index++) {
			// a list of values at every time step
			ArrayList<String> valueListTS = new ArrayList<String>();
			int temp = index;
			for (int k = 0; k <= h; k++) {
				valueListTS.add(domain.get(temp % domainSize));
				temp = temp / domainSize;
			}
			// Collections.reverse(valueListTS);

			double evaluation = utilityMinusSwitchingCost(valueListTS);
			if (evaluation > maxUtility) {
				maxUtility = evaluation;
				bestImproveValueList = valueListTS;
			}
		}

		bestImproveUtilityList = new ArrayList<Double>();
		if (maxUtility != Integer.MIN_VALUE) {
			bestUtilityList = utilityMinusCostOverTSList(bestImproveValueList);
			//if (idStr.equals("1")) System.err.println("best " + bestUtilityList);
			for (int i=0; i<=h; i++) {
				bestImproveUtilityList.add(bestUtilityList.get(i) - currentUtilityList.get(i));
			}
		}

		simulatedTime += bean.getCurrentThreadUserTime() - currentStartTime;
		
		//send IMPROVE messages
		for (AID neighbor:neighborAIDList) {
			sendObjectMessageWithTime(neighbor, bestImproveUtilityList, MESSAGE_TYPE.LS_IMPROVE, simulatedTime);
		}
	}
	
	double utilityMinusSwitchingCost(ArrayList<String> valuesOverTS) {
		double sumUtility = 0;
		double sumCost = 0;
		for (int ts=0; ts<=h; ts++) {
			ArrayList<Table> tableList = constraintTableAtEachTSMap.get(ts);
	    	for (Table constraintTable:tableList) {
				ArrayList<String> decVarList = constraintTable.getDecVarLabel();
				ArrayList<String> decValueList = new ArrayList<String>();
				//get value from agentView
				//add value to decValue -> getUtility
				for (String neighbor:decVarList) {
					if (neighbor.equals(idStr))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentView_DPOP_TSMap.get(neighbor).get(ts));
				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}
		
		for (int i=1; i<valuesOverTS.size(); i++) {
//			sumCost += valuesOverTS.get(i).equals(valuesOverTS.get(i-1)) ? 0
//										: switchingCost * Math.pow(discountFactor, i-1);
//			sumCost += valuesOverTS.get(i).equals(valuesOverTS.get(i-1)) ? 0
//					: switchingCost;
			sumCost += sc_func(valuesOverTS.get(i), valuesOverTS.get(i-1));
		}
		return sumUtility - sumCost;
	}
	
	ArrayList<Double> utilityMinusCostOverTS(HashMap<Integer,String> valuesOverTS) {
		ArrayList<Double> utilityList = new ArrayList<Double>();
		for (int ts=0; ts<=h; ts++) {
			double sc = 0;
			double utility = 0;
			if (ts==0)
//				sc = (valuesOverTS.get(0).equals(valuesOverTS.get(1))
//						? 0 : switchingCost);
				sc = sc_func(valuesOverTS.get(0), valuesOverTS.get(1));
			else if (ts==h) 
//				sc = (valuesOverTS.get(h).equals(valuesOverTS.get(h-1))
//				? 0 : switchingCost);
				sc = sc_func(valuesOverTS.get(h), valuesOverTS.get(h-1));
			else
//				sc = (valuesOverTS.get(ts-1).equals(valuesOverTS.get(ts)) ? 0 : switchingCost)
//				   + (valuesOverTS.get(ts).equals(valuesOverTS.get(ts+1)) ? 0 : switchingCost);
				sc = sc_func(valuesOverTS.get(ts-1), valuesOverTS.get(ts))
				   + sc_func(valuesOverTS.get(ts), valuesOverTS.get(ts+1));
			//from each utility constraint with neighbors at a timeStep
			//get names -> get values from agent_view
			//from neighbors' values, current value -> get utility from constraint table
			ArrayList<Table> tableList = constraintTableAtEachTSMap.get(ts);
//		    System.err.println("Agent " + idStr + " size " + tableList.size());
	    	for (Table constraintTable:tableList) {
				ArrayList<String> decVarList = constraintTable.getDecVarLabel();
				ArrayList<String> decValueList = new ArrayList<String>();
				//get value from agentView
				//add value to decValue -> getUtility
				for (String neighbor:decVarList) {
					if (neighbor.equals(idStr))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentView_DPOP_TSMap.get(neighbor).get(ts));
				}
				utility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
	    	
	    	utilityList.add(utility - sc);
		}
		return utilityList;
	}
	
	//utilityMinusCostOverTSList
	ArrayList<Double> utilityMinusCostOverTSList(ArrayList<String> valuesOverTS) {
		ArrayList<Double> utilityList = new ArrayList<Double>();
		for (int ts=0; ts<=h; ts++) {
			double sc = 0;
			double utility = 0;
			if (ts==0)
//				sc = (valuesOverTS.get(0).equals(valuesOverTS.get(1))
//						? 0 : switchingCost);
				sc = sc_func(valuesOverTS.get(0), valuesOverTS.get(1));
			else if (ts==h) 
//				sc = (valuesOverTS.get(h).equals(valuesOverTS.get(h-1))
//						? 0 : switchingCost);
				sc = sc_func(valuesOverTS.get(h), valuesOverTS.get(h-1));
			else
//				sc = (valuesOverTS.get(ts-1).equals(valuesOverTS.get(ts))
//						? 0 : switchingCost)
//				   + (valuesOverTS.get(ts).equals(valuesOverTS.get(ts+1))
//						? 0 : switchingCost);
				sc = sc_func(valuesOverTS.get(ts-1), valuesOverTS.get(ts))
				   + sc_func(valuesOverTS.get(ts), valuesOverTS.get(ts+1));
			
			//from each utility constraint with neighbors at a timeStep
			//get names -> get values from agent_view
			//from neighbors' values, current value -> get utility from constraint table
			ArrayList<Table> tableList = constraintTableAtEachTSMap.get(ts);
//		    System.err.println("Agent " + idStr + " size " + tableList.size());
	    	for (Table constraintTable:tableList) {
				ArrayList<String> decVarList = constraintTable.getDecVarLabel();
				ArrayList<String> decValueList = new ArrayList<String>();
				//get value from agentView
				//add value to decValue -> getUtility
				for (String neighbor:decVarList) {
					if (neighbor.equals(idStr))
						decValueList.add(valuesOverTS.get(ts));
					else
						decValueList.add(agentView_DPOP_TSMap.get(neighbor).get(ts));
				}
				utility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
	    	
	    	utilityList.add(utility - sc);
		}
		return utilityList;
	}
	
	public void createProbabilityWithObservation(int timeStep) {
		if (timeStep == 0) {
			createProbabilityAt(0);
			return ;
		}
		for (String randVariable:randomVariableList) {
			double distribution[] = toArray(transitionFunctionMap.get
						(randVariable).getTransitionOf(pickedRandomMap.get(timeStep-1)));
			probabilityAtEachTimeStepMap.get(randVariable)[timeStep] = distribution;
		}
	}
	
	public void createProbabilityAt(int timeStep) {
		for (String randVariable:randomVariableList) {
			int size = randomVariableDomainMap.get(randVariable).size();
			if (timeStep == 0) {
				ArrayList<Double> initProbList = initProabilityMap.get(randVariable);
				for (int i=0; i<size; i++) {
					probabilityAtEachTimeStepMap.get(randVariable)[0][i] = initProbList.get(i);
				}
			}
			else {
				double[] prevDistribution = probabilityAtEachTimeStepMap.get(randVariable)[timeStep-1];
				double[] currDistribution = multiply(prevDistribution, transitionFunctionMap.get(randVariable));
				probabilityAtEachTimeStepMap.get(randVariable)[timeStep] = currDistribution;
			}
		}	
	}
	
	public void createStableProbabilityForLastTimeStep() {
		//for each random variables
		for (String randVariable:randomVariableList) {
			double distribution[] = probabilityAtEachTimeStepMap.get(randVariable)[0];
			//multiply to get stable distribution
			for (int i=0; i<=DCOP.stableTimeStep; i++) {
				distribution = multiply(distribution, transitionFunctionMap.get(randVariable));
			}
			probabilityAtEachTimeStepMap.get(randVariable)[h] = distribution;
		}
	}
	
	//for each agent, create probability for valueList at each timeStep of each randomVariable
	//add to probabilityAtEachTimeStepMap
	public void createAndAddProbabilityAtEachTimeStep() {
		//get each random Variable from randomVariableList
		//add to probabilityAtEachTimeStepMap
		//int columnNo = timeStepAllowed + 1;
		int columnNo = h + 1;
		for (int randVarIndex=0; randVarIndex<randomVariableList.size(); randVarIndex++) {
			String randVariable = randomVariableList.get(randVarIndex);
			int domainSize = randomVariableDomainMap.get(randVariable).size();
			//each row is a timeStep from 0 to finalTimeStep
			//each column is a value from domain
			double[][] probAtEachTS = new double[columnNo][domainSize];
			TransitionFunction transMatrix = transitionFunctionMap.get(randVariable);
			for (int row=0; row<columnNo; row++) {
				if (row==0) {
					ArrayList<Double> initProbList = initProabilityMap.get(randVariable);
					for (int col=0; col<domainSize; col++) {
						probAtEachTS[row][col] = initProbList.get(col); 
					}
					continue;						
				}
				for (int col=0; col<domainSize; col++) {
					double probabilityAtATime = 0;
					for (int upperCol=0; upperCol<domainSize; upperCol++) {
						probabilityAtATime += probAtEachTS[row-1][upperCol] * 
								transMatrix.getProbByIndex(upperCol, col); 
					}
					probAtEachTS[row][col] = probabilityAtATime;
				}
			}
			probabilityAtEachTimeStepMap.put(randVariable, probAtEachTS);
		}
	}
	
	void reorganizeRandomTable() {
		//traverse each constraint table in constrainTableList
		//create new constraintTableList
		for (Table constraintRandTable:constraintTableWithRandomList) {
			organizedConstraintTableWithRandomList.add(constraintRandTable);
		}			
	}
	
	ArrayList<ArrayList<String>> getAllTupleValueOfGivenLabel(ArrayList<String> varLabel, boolean isDecVar) {
		ArrayList<ArrayList<String>> allTuple = new ArrayList<ArrayList<String>>();
		ArrayList<Integer> sizeDomainList = new ArrayList<Integer>();
		int totalSize = 1;
		for (String randVar:varLabel) {
			int domainSize = 0;
			
			if (isDecVar) {
				domainSize = decisionVariableDomainMap.get(randVar).size();
			}
			else
				domainSize = randomVariableDomainMap.get(randVar).size();
			sizeDomainList.add(domainSize);
			totalSize *= domainSize;
		}
		
		int noVar = varLabel.size();
		
		//go from 0 to totalSize
		for (int count=0; count<totalSize; count++) {
			ArrayList<String> valueTuple = new ArrayList<String>();
			int quotient = count;
			//for each value count, decide the index of each column, then add to the tuple
			for (int varIndex = noVar-1; varIndex>=0; varIndex--) {
				int remainder = quotient%sizeDomainList.get(varIndex);
				quotient = quotient/sizeDomainList.get(varIndex);
				if (isDecVar)
					valueTuple.add(decisionVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
				else 
					valueTuple.add(randomVariableDomainMap.get(varLabel.get(varIndex)).get(remainder));
			}
			Collections.reverse(valueTuple);
			allTuple.add(valueTuple);
		}
		
		return allTuple;
	}
	
	void reorganizeConstaintTable() {
		//traverse each constraint table in constrainTableList
		//create new constraintTableList
		for (Table constraintTable:constraintTableWithoutRandomList) {
			organizedConstraintTableList.add(constraintTable);
		}
	}
	
	boolean isConstraintTableAtEachTSMapNull(int indexInConstraintTableMap) {
		ArrayList<Table> tableList = constraintTableAtEachTSMap.get(indexInConstraintTableMap);
		if (tableList == null)	return true;
		else	
			return false;
	}
	
	public void addConstraintTableToList(int timeStep) {
		// traverse table in organizedConstraintTableList
		for (Table decTable : organizedConstraintTableList) {
			ArrayList<String> decLabel = decTable.getDecVarLabel();
			// for each table, run time step from 0 to allowed
			// for (int tS=0; tS<=solveTimeStep; tS++) {
			Table newTable = new Table(decLabel);

			// at each timeStep, traverse rows
			for (Row row : decTable.getTable()) {
				double updatedUtility = 0;
				updatedUtility = row.getUtility();
				newTable.addRow(new Row(row.getValueList(), updatedUtility));
			}
			constraintTableAtEachTSMap.get(timeStep).add(newTable);
		}
	}
	public void addConstraintTableToListAllTS() {		
		//traverse table in organizedConstraintTableList
		for (Table decTable:organizedConstraintTableList) {
			ArrayList<Table> tableAtTSList = new ArrayList<Table>();
			ArrayList<String> decLabel = decTable.getDecVarLabel();
			//for each table, run time step from 0 to allowed
			for (int tS=0; tS<=h; tS++) {
				Table newTable = new Table(decLabel);
				
				//at each timeStep, traverse rows
				for (Row row:decTable.getTable()) {
					double updatedUtility = 0;
					updatedUtility = row.getUtility();
					newTable.addRow(new Row(row.getValueList(), updatedUtility));
				}
				if (algorithm == C_DPOP) {
					tableAtTSList.add(newTable);
				}
				else if (algorithm == LS_RAND) { 
					constraintTableAtEachTSMap.get(tS).add(newTable);
				}
			}
			if (algorithm == C_DPOP) {
				constraintTableAtEachTSMap.get(0).add(joinConstraintTable(tableAtTSList));
			}
		}
	}
	
	//they have the same entry, only different utility
	public Table joinConstraintTable(ArrayList<Table> tableList) {
		if (tableList.size() == 0) return null;
		Table joinedTable = new Table(tableList.get(0).getDecVarLabel());
		int noVar = tableList.get(0).getDecVarLabel().size();
		int entryNumber = tableList.get(0).getRowCount();
		int noTable = tableList.size();
		int totalSize = (int) Math.pow(entryNumber, noTable);
		
		for (int count=0; count<totalSize; count++) {
			ArrayList<String> valueTuple = new ArrayList<String>(noVar);
			for (int i=0; i<noVar; i++) valueTuple.add("");
			double sumUtility = 0;
			int quotient = count;
			//for each table count, decide the index of each column, then add to the tuple
			for (int tableIndex = noTable-1; tableIndex>=0; tableIndex--) {
				int remainder = quotient%entryNumber;
				quotient = quotient/entryNumber;
				Row row = tableList.get(tableIndex).getTable().get(remainder);
				sumUtility += row.getUtility();
				ArrayList<String> valueList = row.getValueList();
				for (int idx=0; idx<valueList.size(); idx++) {
					valueTuple.set(idx, valueList.get(idx) + "," + valueTuple.get(idx));
				}
			}
			for (int idx=0; idx<valueTuple.size(); idx++) {
				valueTuple.set(idx, valueTuple.get(idx).substring(0, valueTuple.get(idx).length()-1));
			}
			joinedTable.addRow(new Row(valueTuple, sumUtility));
		}
	
		return joinedTable;
	}

	public void addExpectedRandomTableToList(int timeStep) {
		//loop over number of each organized constraint random table
		for (Table randTable:organizedConstraintTableWithRandomList) {
			ArrayList<String> decLabel = randTable.getDecVarLabel();
			ArrayList<String> randLabel = randTable.getRandVarLabel();
			
			int randDomainSize = 1;
			for (String randVar:randLabel) {
				randDomainSize *= randomVariableDomainMap.get(randVar).size();
			}
							
			Table tempTable;				
			tempTable = randTable;
			Table newTable = new Table(decLabel);
			double expectedUtility = 0;
			//traverse rows
			for (int index=0; index<tempTable.getRowCount(); index++) {
				Row row = tempTable.getTable().get(index);
				ArrayList<String> decValueList = row.getValueList();
				ArrayList<String> randValueList = row.getRandomList();
				double initProb = 1;
				for (int idx=0; idx<randLabel.size(); idx++) {
					String rand = randLabel.get(idx);
					initProb *= probabilityAtEachTimeStepMap.
							get(rand)[timeStep][randomVariableDomainMap.get(rand).
										  indexOf(randValueList.get(idx))];
				}
				expectedUtility += initProb*row.getUtility();
				
				//last turn
				if (index%randDomainSize == randDomainSize-1) {
					Row newRow = null;
					newRow = new Row(decValueList, expectedUtility);
					newTable.addRow(newRow);
					expectedUtility = 0;
				}
			//end of traversing row
			}
			constraintTableAtEachTSMap.get(timeStep).add(newTable);
		//end of traversing random table
		}
	
	}
	
	//initializing constraintTableAtEachTimeStepMap(timeStep, listOfTables)
	//calculate expected utility, and eliminate random variables
	public void addExpectedRandomTableToListAllTS() {		
		//loop over number of each organized constraint random table
		for (Table randTable:organizedConstraintTableWithRandomList) {
			ArrayList<Table> tableAtTSList = new ArrayList<Table>();
			ArrayList<String> decLabel = randTable.getDecVarLabel();
			ArrayList<String> randLabel = randTable.getRandVarLabel();
			
			int randDomainSize = 1;
			for (String randVar:randLabel) {
				randDomainSize *= randomVariableDomainMap.get(randVar).size();
			}
			
			//loop over timeStep -> timeStepAllow-1
			for (int tS=0; tS<=h; tS++) {				
				Table tempTable;				
				tempTable = randTable;
				Table newTable = new Table(decLabel);
				double expectedUtility = 0;
				//traverse rows
				for (int index=0; index<tempTable.getRowCount(); index++) {
					Row row = tempTable.getTable().get(index);
					ArrayList<String> decValueList = row.getValueList();
					ArrayList<String> randValueList = row.getRandomList();
					double initProb = 1;
					for (int idx=0; idx<randLabel.size(); idx++) {
						String rand = randLabel.get(idx);
						initProb *= probabilityAtEachTimeStepMap.
								get(rand)[tS][randomVariableDomainMap.get(rand).
											  indexOf(randValueList.get(idx))];
					}
					expectedUtility += initProb*row.getUtility();
					
					//last turn
					if (index%randDomainSize == randDomainSize-1) {
						Row newRow = null;
						newRow = new Row(decValueList, expectedUtility);
						newTable.addRow(newRow);
						expectedUtility = 0;
					}
				//end of traversing row
				}
				if (algorithm == C_DPOP) {
					//add table to tableAtTSList to be joined later
					tableAtTSList.add(newTable);
				}
				else if (algorithm == LS_RAND) { 
					constraintTableAtEachTSMap.get(tS).add(newTable);
				}
				//end of loop timeStep
			}
			//at the end of traversing timeStep from 0 -> stableTimeStep,
			//join all of expected table, and add the joinedTable to timeStep 0
			//tables at last stableTimeStep been added to last time step
			if (algorithm == C_DPOP) {
				constraintTableAtEachTSMap.get(0).add(joinConstraintTable(tableAtTSList));
			}			
		//end of traversing random table
		}
	}
	
//	public Table collapseGivenRandomTable(Table tableWithRandom) {		
//		Table newlyCreatedTable;
//		ArrayList<ArrayList<String>> processedDecValues = new ArrayList<ArrayList<String>>();
//		
//		ArrayList<String> decVarLabel = tableWithRandom.getDecVarLabel();
//		ArrayList<String> randVarLabel = tableWithRandom.getRandVarLabel();
//		ArrayList<ArrayList<String>> allTupleValue = getAllTupleValueOfGivenLabel(randVarLabel, false);
//		newlyCreatedTable = new Table(decVarLabel, randVarLabel);
//		
//		int noOfEquations = 1;
//		for (String randVar:randVarLabel) {
//			noOfEquations *= randomVariableDomainMap.get(randVar).size();
//		}
//
//		//traverse each row of tableWithRandom
//		for (Row rowToBeTraversed:tableWithRandom.getTable()) {
//			ArrayList<String> decValueList = rowToBeTraversed.getValueList();
//
//			//ArrayList<String> randValueList = rowToBeTraversed.getRandomList();
//			
//			//check if decValueList contained in processedDecValues
//			if (isArrayContainedInOtherArray(processedDecValues,decValueList)) {
//
//				continue;
//			} //search for all values of random Variable
//			else if (isArrayContainedInOtherArray(processedDecValues,decValueList) == false) {
//				processedDecValues.add(decValueList);
//				/** construct unknown equations, by add coefficients
//				 *
//				 * construct coefficients
//				 *  (1-delta*prob[0,0] - delta*prob[0,1] ... - delta*prob[0,n]  = v0
//				 *  -delta*prob[1,0] + (1-delta*prob[1,1] ...- delta*prob[1,n]  = v1
//				 *
//				 *  -delta*prob[n,0] - delta*prob[n,1] ... + (1-delta*prob[n,n] = v_n
//				 **/
//				double coefficients[][] = new double[noOfEquations][noOfEquations+1];
//				//select rowTuple => colTuple
//				for (int row=0; row<noOfEquations; row++) {
//					ArrayList<String> rowTuple = allTupleValue.get(row); 
//					//get colTuple
//					for (int column=0; column<noOfEquations; column++) {
//						ArrayList<String> colTuple = allTupleValue.get(column);
//						double transProb = 1;
//						for (int randIndex=0; randIndex < randVarLabel.size(); randIndex++) {
//							String randVar = randVarLabel.get(randIndex);
//							transProb = transProb * transitionFunctionMap.get(randVar).
//									getProbByValue(rowTuple.get(randIndex),
//													colTuple.get(randIndex));
//						}
//						
//						
//						if (row == column)
//							coefficients[row][column] = 1 - discountFactor*transProb;
//						else
//							coefficients[row][column] = -discountFactor*transProb;
//						
//					}
//					//set utility
//					coefficients[row][noOfEquations] = getUtilityFromTableGivenDecAndRand(tableWithRandom, decValueList, rowTuple);
//				}
//				
////				System.out.println(Arrays.deepToString(coefficients));
//				ArrayList<Double> utilityList = gaussian(coefficients, noOfEquations);
//				
////				if (idStr.equals("0")) System.out.println(utilityList);
//				//create new row with a fix dec values, but different rand values
//				int i = 0;
//				for (ArrayList<String> randValueToBeAddedList:allTupleValue) {
//					Row newRow = new Row(decValueList, randValueToBeAddedList, utilityList.get(i));
//					i++;
//					newlyCreatedTable.addRow(newRow);
//				}
//			//end if: decValueList not contained
//			}
//		//end while: traversing table 
//		}
//		return newlyCreatedTable;
//	}
	
	boolean isArrayContainedInOtherArray(ArrayList<ArrayList<String>> bigArray, ArrayList<String> smallArray) {
		if (bigArray.size() == 0 || smallArray.size() == 0)
			return false;
		for (ArrayList<String> traversal:bigArray) {
			boolean isArrayFound = true;
			if (traversal.size() != smallArray.size()) {
				System.out.println("!!!!!!Different size!!!!!!");
				continue;
			}
			for (int i=0; i<traversal.size(); i++) {
				if (traversal.get(i).equals(smallArray.get(i)) == false) {
					isArrayFound = false;
					break;
				}
					
			}
			if (isArrayFound == false)	continue;
			return true;
		}
		
		return false;
	}

	double getUtilityFromTableGivenDecAndRand(Table table, ArrayList<String> decValueList, ArrayList<String> randIterationValue) {
		ArrayList<Row> tableToTraversed = table.getTable();
		for (Row row:tableToTraversed) {
			boolean isRowFound = true;
			//System.err.println("Utility of this row " + row.getUtility());
			ArrayList<String> rowValueList = row.getValueList();
			ArrayList<String> rowRandomList= row.getRandomList();

			if (rowValueList.size() != decValueList.size() || rowRandomList.size() != randIterationValue.size()) {
				System.err.println("!!!!!!Different size!!!!!!!!!");
				System.err.println("!!!!!!Recheck your code!!!!!!");
			}
			for (int index=0; index<decValueList.size(); index++) {
				if (rowValueList.get(index).equals(decValueList.get(index)) == false) {
					isRowFound = false;
					break;
				}
			}
			
			if (isRowFound == false)	continue;
			
			for (int index=0; index<randIterationValue.size(); index++) {
				if (rowRandomList.get(index).equals(randIterationValue.get(index)) == false) {
					isRowFound = false;
					break;
				}
			}
			
			if (isRowFound == false)	continue;
			
			return row.getUtility();
		}
		System.out.println("Not found!!!!!!!!!!!!!!");
		return Integer.MIN_VALUE;
	}

	public ArrayList<Double> gaussian(double arr[][], int N) {
		ArrayList<Double> longtermUtilityList = new ArrayList<Double>();
		// take each line as pivot, except for the last line
		for (int pivotIndex = 0; pivotIndex < N - 1; pivotIndex++) {
			// go from the line below line pivotIndex, to the last line
			boolean isNotZeroRowFound = false;
			if (arr[pivotIndex][pivotIndex] == 0) {
				int notZeroRow;
				for (notZeroRow = pivotIndex + 1; notZeroRow < N; notZeroRow++) {
					if (arr[notZeroRow][pivotIndex] != 0) {
						isNotZeroRowFound = true;
						break;
					}
				}

				if (isNotZeroRowFound) {
					// swap row pivotIndex and row notZeroRow
					for (int columnToSwapIndex = 0; columnToSwapIndex < N + 1; columnToSwapIndex++) {
						double tempForSwap = arr[pivotIndex][columnToSwapIndex];
						arr[pivotIndex][columnToSwapIndex] = arr[notZeroRow][columnToSwapIndex];
						arr[notZeroRow][columnToSwapIndex] = tempForSwap;
					}
				} else {
					continue;
				}
			}

			for (int rowForGauss = pivotIndex + 1; rowForGauss < N; rowForGauss++) {
				double factor = arr[rowForGauss][pivotIndex]
						/ arr[pivotIndex][pivotIndex];
				for (int columnForGauss = 0; columnForGauss < N + 1; columnForGauss++) {
					arr[rowForGauss][columnForGauss] = arr[rowForGauss][columnForGauss]
							- factor * arr[pivotIndex][columnForGauss];
				}
			}
		}

		for (int columnPivot = N - 1; columnPivot >= 1; columnPivot--) {
			for (int rowAbovePivot = columnPivot - 1; rowAbovePivot >= 0; rowAbovePivot--) {
				double fraction = arr[rowAbovePivot][columnPivot]
						/ arr[columnPivot][columnPivot];
				for (int columnInTheRow = 0; columnInTheRow < N + 1; columnInTheRow++)
					arr[rowAbovePivot][columnInTheRow] = arr[rowAbovePivot][columnInTheRow]
							- fraction * arr[columnPivot][columnInTheRow];
			}
		}
		
		for (int i=0; i<N; i++) { 
			longtermUtilityList.add(arr[i][N]/arr[i][i]); 
		}
		
		return longtermUtilityList;

	}
		
	public void sendObjectMessage(AID receiver, Object content, int msgCode) {
		ACLMessage message = new ACLMessage(msgCode);
		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		send(message);
	}
	
	public void sendObjectMessageWithTime(AID receiver, Object content, int msgCode, long time) {
		ACLMessage message = new ACLMessage(msgCode);
		try {
			message.setContentObject((Serializable) content);
		} catch (IOException e) {
			e.printStackTrace();
		}
		message.addReceiver(receiver);
		message.setLanguage(String.valueOf(time));
		send(message);
	}


	public void printTree(boolean isRoot) {
		System.out.println("************");
		System.out.println("My ID is: " + idStr);
		if (isRoot == false)
			System.out.println("My parent is: " + parentAID.getLocalName());
		System.out.println("My children are: ");
		for (int i=0;i<childrenAIDList.size();i++) {
			System.out.print(childrenAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();
		
		System.out.println("My pseudo_parents are: ");
		for (int i=0;i<pseudoParentAIDList.size();i++) {
			System.out.print(pseudoParentAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();
		
		System.out.println("My pseudo_children are: ");
		for (int i=0;i<pseudoChildrenAIDList.size();i++) {
			System.out.print(pseudoChildrenAIDList.get(i).getLocalName() + " ");
		}
		System.out.println();
		
	}
	
	public void readMinizincFileThenParseNeighborAndConstraintTable(String inputFileName) {
		final String RANDOM_VARIABLE = "random";
		final String DECISION_VARIABLE = "decision";
		final String REWARD_TABLE_PREFIX = "rewardTable";
		final String TRANS_FUNC_PREFIX = "transition";
		final String INIT_PROB_PREFIX = "initProbability";
		
		try (BufferedReader br = new BufferedReader(new FileReader(
				System.getProperty("user.dir") + '/' + inputFileName))) {
			ArrayList<String> lineWithSemiColonList = new ArrayList<String>();
			
			String line = br.readLine();
			while (line != null) {
				if (line.length() == 0 || line.startsWith("%") == true) {
					line = br.readLine();
					continue;
				}
				
				//concatenate line until meet ';'
				if (line.endsWith(";") == false) {
					do {
						line += br.readLine();
					} while (line.endsWith(";") == false);
				}
				
				line = line.replace(" ","");
				line = line.replace(";","");
				lineWithSemiColonList.add(line);
				line = br.readLine();
			}
			
			//Process line by line;
			for (String lineWithSemiColon:lineWithSemiColonList) {
				//print input file for agent0
				String nameMzn = lineWithSemiColon.split("=")[0];
				String valueMzn = lineWithSemiColon.split("=")[1];
				
				/**DISCOUNT_FACTOR*/
//				if (nameMzn.contains(DISCOUNT_FACTOR)) {
//					discountFactor = Double.parseDouble(valueMzn);
//				}
				/**TIME_STEP*/
//				if (nameMzn.contains(TIME_STEP)) {
//					timeStepAllowed = Integer.parseInt(valueMzn);	
//				}
				/**SWITCHING_COST*/
//				if (nameMzn.contains(SWITCHING_COST)) {
//					switchingCost = Double.parseDouble(valueMzn);			
//				}
				/**TRANS_FUNC_PREFIX*/
				if (nameMzn.contains(TRANS_FUNC_PREFIX)) {
					String randomVariable;
					ArrayList<ArrayList<Double>> newTransitionMatrix;
			
					nameMzn = nameMzn.replaceAll(TRANS_FUNC_PREFIX, "");
					randomVariable = nameMzn;
					
					//TODO: read variable with idString only
					if (randomVariable.equals(idStr) == false) continue;

					/**create transition function**/
					newTransitionMatrix = new ArrayList<ArrayList<Double>>();
					ArrayList<String> listOfRow;
					/**process table values**/
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					valueMzn = valueMzn.substring(1, valueMzn.length()-1);
					listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
					for (String oneRow:listOfRow) {
						ArrayList<String> valueStrList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
						ArrayList<Double> valueDoubleList = new ArrayList<Double>();
						
						for (String valueStr:valueStrList) {
							valueDoubleList.add(Double.parseDouble(valueStr));
						}
						newTransitionMatrix.add(valueDoubleList);
					}
					TransitionFunction newTransitionFunction = new TransitionFunction(
							randomVariableDomainMap.get(randomVariable), newTransitionMatrix);
					transitionFunctionMap.put(randomVariable, newTransitionFunction);
				}
				/**INIT_PROB_PREFIX*/
				if (nameMzn.contains(INIT_PROB_PREFIX)) {
					String randomVariable;
					ArrayList<String> initProbabilityStrList;
					ArrayList<Double> initProbabilityDoubleList = new ArrayList<Double>();
					nameMzn = nameMzn.replace(INIT_PROB_PREFIX, "");
					randomVariable = nameMzn;
					
					//TODO: read variable with idString only
					if (randomVariable.equals(idStr) == false) continue;
					
					//process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					initProbabilityStrList = new ArrayList<String>(Arrays.asList(valueMzn.split(",")));
					for (String strValue:initProbabilityStrList) {
						initProbabilityDoubleList.add(Double.parseDouble(strValue));
					}
					initProabilityMap.put(randomVariable, initProbabilityDoubleList);
				}
				/**DECISION_VARIABLE*/
				//read decision variable domain
				if (nameMzn.contains(DECISION_VARIABLE)) {
					//process name
					String decisionVariable;
					ArrayList<String> valueOfDecisionVariableList;
					nameMzn = nameMzn.replace(DECISION_VARIABLE, "");
					decisionVariable = nameMzn;
					
					//process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					valueOfDecisionVariableList = new ArrayList<String>(Arrays.asList(valueMzn.split(",")));
					
					decisionVariableList.add(decisionVariable);
					decisionVariableDomainMap.put(decisionVariable, valueOfDecisionVariableList);
				}
				/**RANDOM_VARIABLE*/
				//read random variable domain
				if (nameMzn.contains(RANDOM_VARIABLE)) {
					//process name
					String randomVariable;
					ArrayList<String> valueOfRandomVariableList;
					nameMzn = nameMzn.replace(RANDOM_VARIABLE, "");
					randomVariable = nameMzn;
					
					//TODO: read variable with idString only
					if (randomVariable.equals(idStr) == false) continue;
					
					//process values
					valueMzn = valueMzn.replace("[", "");
					valueMzn = valueMzn.replace("]", "");
					valueOfRandomVariableList = new ArrayList<String>(Arrays.asList(valueMzn.split(",")));
					randomVariableList.add(randomVariable);
					randomVariableDomainMap.put(randomVariable, valueOfRandomVariableList);
				}
				/**REWARD_TABLE_PREFIX*/
				/**process name of constraint table, create table with the corresponding name**/
				if (nameMzn.contains(REWARD_TABLE_PREFIX)) {
					Table newRewardTable;
					ArrayList<String> variableLabel;
					ArrayList<String> listOfRow;
					nameMzn = nameMzn.replaceAll(REWARD_TABLE_PREFIX + "_", "");
					
					variableLabel = new ArrayList<String>(Arrays.asList(nameMzn.split("_")));
					/**Variable List does not contain its agent variable
					 * So we skip to process the next line*/
					if (variableLabel.contains("d" + idStr) == false)
						continue;
					/****WITHOUT random variable**********/
					boolean notContainRandom = true;
					for (String var:variableLabel) {
						if (var.startsWith("r")) {
							notContainRandom = false;
							break;
						}
					}
					if (notContainRandom == true) {
						/**add variable to neighborList**/
						ArrayList<String> variableLabel_new = new ArrayList<>();
						for (String var:variableLabel) {
							/*add to neighbor list*/
							var = var.replace("d", "");
							if (!var.equals(idStr) && !neighborStrList.contains(var))
								neighborStrList.add(var);
							variableLabel_new.add(var);
						}
						/**create Table**/
						newRewardTable = new Table(variableLabel_new);
						
						/**process table values**/
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");
						valueMzn = valueMzn.substring(1, valueMzn.length()-1);
						listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
						
						for (String oneRow:listOfRow) {
							ArrayList<String> valueList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
							double utility = Double.parseDouble(valueList.get(valueList.size()-1));
							valueList.remove(valueList.size()-1);
							Row newRow = new Row(valueList,utility);
							newRewardTable.addRow(newRow);
						}
						constraintTableWithoutRandomList.add(newRewardTable);
					}
					/****WITH random variable**********/
					else {
						/**Process nameMzn*/
						int decisionVarCount = 0;
						ArrayList<String> decVarLabel = new ArrayList<String>();
						ArrayList<String> randVarLabel = new ArrayList<String>();
						for (String var:variableLabel) {
							if (var.startsWith("d")) {
								decisionVarCount++;
								decVarLabel.add(var.replace("d", ""));
							}
							else if (var.startsWith("r")) {
								randVarLabel.add(var.replace("r", ""));
							}
						}
						/**add variable to neighborList**/
						for (String var:decVarLabel) {
							/*add to neighbor list*/
							if (!neighborStrList.contains(var) && !var.equals(idStr)) {
								neighborStrList.add(var);
							}
						}
						/**create Table**/
						//System.out.println("!" + decVarLabel + " " + randVarLabel);
						newRewardTable = new Table(decVarLabel, randVarLabel);
						
						/**process table values**/
						valueMzn = valueMzn.replace("[", "");
						valueMzn = valueMzn.replace("]", "");
						valueMzn = valueMzn.substring(1, valueMzn.length()-1);
						listOfRow = new ArrayList<String>(Arrays.asList(valueMzn.split("\\|")));
						for (String oneRow:listOfRow) {
							ArrayList<String> decAndRandValueList = new ArrayList<String>(Arrays.asList(oneRow.split(",")));
							ArrayList<String> decValueList = new ArrayList<String>();
							ArrayList<String> randValueList = new ArrayList<String>();
							double utility = Double.parseDouble(decAndRandValueList.get(decAndRandValueList.size()-1));
							decAndRandValueList.remove(decAndRandValueList.size()-1);
							for (int i = 0; i < decisionVarCount; i++) {
								decValueList.add(decAndRandValueList.get(i));
							}
							for (int i = decisionVarCount; i<decAndRandValueList.size(); i++) {
								randValueList.add(decAndRandValueList.get(i));
							}
							Row newRow = new Row(decValueList, randValueList, utility);
							newRewardTable.addRow(newRow);
						}
						constraintTableWithRandomList.add(newRewardTable);
					}
				}
			}
			
			/**Place to test printing out*/
			/**end of testing*/
		}
		catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public void registerWithDF () {
		DFAgentDescription dfd = new DFAgentDescription();
		dfd.setName(getAID());
		for (int i=0; i<neighborStrList.size(); i++) {
			ServiceDescription sd = new ServiceDescription();
			sd.setType(neighborStrList.get(i));
			sd.setName(idStr);
			dfd.addServices(sd);
		}
		try {
			DFService.register(this, dfd);
		}
		catch (FIPAException fe) {
			fe.printStackTrace();
		}
	}
	
	//get utility with parents, pseudoparents
	//then add its switching cost
	public double utilityWithParentAndPseudoAndUnary() {
		double sumUtility = 0;

		for (int ts=0; ts<=h; ts++) {
			ArrayList<Table> tableList = constraintTableAtEachTSMap.get(ts);
	    	for (Table constraintTable:tableList) {
				ArrayList<String> decVarList = constraintTable.getDecVarLabel();
				ArrayList<String> decValueList = new ArrayList<String>();
				
				//chi gui vi constraint voi parent and pseudoparents
				boolean notInParentList = false;
				for (String var:decVarList) {
					if (var.equals(idStr))
						continue;
					if (parentAndPseudoStrList.contains(var) == false) {
						notInParentList = true;
						break;
					}
				}
				
				if (notInParentList)
					continue;
				
				for (String agentInList:decVarList) {
					if (agentInList.equals(idStr))
						decValueList.add(valueAtEachTSMap.get(ts));
					else
						decValueList.add(agentView_DPOP_TSMap.get(agentInList).get(ts));
				}
				sumUtility += constraintTable.getUtilityGivenDecValueList(decValueList);
			}
		}
		return sumUtility;
	}
	
	public double calculcatingSwitchingCost() {
		double sC = 0;
		if (getValueAtEachTSMap().size() == 1) return 0;
		for (int i=1; i<getValueAtEachTSMap().size(); i++) {
//			if (getValueAtEachTSMap().get(i).equals(getValueAtEachTSMap().get(i-1)) == false)
//				sC += switchingCost;
			
			sC += sc_func(getValueAtEachTSMap().get(i), getValueAtEachTSMap().get(i-1));
		}
		return sC;
	}

	public String getIdStr() {
		return idStr;
	}

	public void setIdStr(String idStr) {
		this.idStr = idStr;
	}

	public boolean isRoot() {
		return isRoot;
	}

	public void setRoot(boolean isRoot) {
		this.isRoot = isRoot;
	}

	public boolean isLeaf() {
		return isLeaf;
	}

	public void setLeaf(boolean isLeaf) {
		this.isLeaf = isLeaf;
	}

	public ArrayList<AID> getNeighborAIDList() {
		return neighborAIDList;
	}

	public void setNeighborAIDList(ArrayList<AID> neighborAIDList) {
		this.neighborAIDList = neighborAIDList;
	}

	public ArrayList<String> getNeighborStrList() {
		return neighborStrList;
	}

	public void setNeighborStrList(ArrayList<String> neighborStrList) {
		this.neighborStrList = neighborStrList;
	}

	public HashMap<AID, Integer> getConstraintInfoMap() {
		return constraintInfoMap;
	}

	public void setConstraintInfoMap(HashMap<AID, Integer> constraintInfoMap) {
		this.constraintInfoMap = constraintInfoMap;
	}

	public boolean isNotVisited() {
		return notVisited;
	}

	public void setNotVisited(boolean notVisited) {
		this.notVisited = notVisited;
	}

	public ArrayList<AID> getChildrenAIDList() {
		return childrenAIDList;
	}

	public void setChildrenAIDList(ArrayList<AID> childrenAIDList) {
		this.childrenAIDList = childrenAIDList;
	}

	public AID getParentAID() {
		return parentAID;
	}

	public void setParentAID(AID parentAID) {
		this.parentAID = parentAID;
	}

	public ArrayList<String> getParentAndPseudoStrList() {
		return parentAndPseudoStrList;
	}

	public void setParentAndPseudoStrList(ArrayList<String> parentAndPseudoStrList) {
		this.parentAndPseudoStrList = parentAndPseudoStrList;
	}

	public ArrayList<AID> getPseudoChildrenAIDList() {
		return pseudoChildrenAIDList;
	}

	public void setPseudoChildrenAIDList(ArrayList<AID> pseudoChildrenAIDList) {
		this.pseudoChildrenAIDList = pseudoChildrenAIDList;
	}

	public ArrayList<AID> getPseudoParentAIDList() {
		return pseudoParentAIDList;
	}

	public void setPseudoParentAIDList(ArrayList<AID> pseudoParentAIDList) {
		this.pseudoParentAIDList = pseudoParentAIDList;
	}

	public ThreadMXBean getBean() {
		return bean;
	}

	public void setBean(ThreadMXBean bean) {
		this.bean = bean;
	}

	public long getCurrentStartTime() {
		return currentStartTime;
	}

	public void setCurrentStartTime(long currentStartTime) {
		this.currentStartTime = currentStartTime;
	}

	public HashMap<String, ArrayList<String>> getDecisionVariableDomainMap() {
		return decisionVariableDomainMap;
	}

	public void setDecisionVariableDomainMap(
			HashMap<String, ArrayList<String>> decisionVariableDomainMap) {
		this.decisionVariableDomainMap = decisionVariableDomainMap;
	}

	public HashMap<Integer, String> getValueAtEachTSMap() {
		return valueAtEachTSMap;
	}

	public void setValueAtEachTSMap(HashMap<Integer, String> valueAtEachTSMap) {
		this.valueAtEachTSMap = valueAtEachTSMap;
	}

	public long getSimulatedTime() {
		return simulatedTime;
	}

	public void setSimulatedTime(long simulatedTime) {
		this.simulatedTime = simulatedTime;
	}
	
	public void addupSimulatedTime(long time) {
		this.simulatedTime += time;
	}

	public ArrayList<Table> getCurrentTableListDPOP() {
		return currentTableListDPOP;
	}

	public void setCurrentTableListDPOP(ArrayList<Table> currentTableListDPOP) {
		this.currentTableListDPOP = currentTableListDPOP;
	}

	public HashMap<Integer, ArrayList<Table>> getConstraintTableAtEachTSMap() {
		return constraintTableAtEachTSMap;
	}

	public void setConstraintTableAtEachTSMap(
			HashMap<Integer, ArrayList<Table>> constraintTableAtEachTSMap) {
		this.constraintTableAtEachTSMap = constraintTableAtEachTSMap;
	}

	public Table getCollapsedSwitchingCostTable() {
		return collapsedSwitchingCostTable;
	}

	public void setCollapsedSwitchingCostTable(Table collapsedSwitchingCostTable) {
		this.collapsedSwitchingCostTable = collapsedSwitchingCostTable;
	}

	public int getCurrentTS() {
		return currentTS;
	}

	public void setCurrentTS(int currentTS) {
		this.currentTS = currentTS;
	}
	
	public void incrementCurrentTS() {
		this.currentTS++;
	}

	public Table getAgentViewTable() {
		return agentViewTable;
	}

	public void setAgentViewTable(Table agentViewTable) {
		this.agentViewTable = agentViewTable;
	}

	public String getChosenValue() {
		return chosenValue;
	}

	public void setChosenValue(String chosenValue) {
		this.chosenValue = chosenValue;
	}

	public ArrayList<Double> getCurrentGlobalUtilityList() {
		return currentGlobalUtilityList;
	}

	public void setCurrentGlobalUtilityList(
			ArrayList<Double> currentGlobalUtilityList) {
		this.currentGlobalUtilityList = currentGlobalUtilityList;
	}

	public double getCurrentGlobalUtility() {
		return currentGlobalUtility;
	}

	public void setCurrentGlobalUtility(double currentGlobalUtility) {
		this.currentGlobalUtility = currentGlobalUtility;
	}

	public double getTotalGlobalUtility() {
		return totalGlobalUtility;
	}

	public void setTotalGlobalUtility(double totalGlobalUtility) {
		this.totalGlobalUtility = totalGlobalUtility;
	}

	public static long getDelayMessageTime() {
		return delayMessageTime;
	}

	public static void setDelayMessageTime(long delayMessageTime) {
		DCOP.delayMessageTime = delayMessageTime;
	}

	public double getUtilFromChildrenLS() {
		return utilFromChildrenLS;
	}

	public void setUtilFromChildrenLS(double utilFromChildrenLS) {
		this.utilFromChildrenLS = utilFromChildrenLS;
	}
	
	public void addtoUtilFromChildrenLS(double util) {
		this.utilFromChildrenLS += util;
	}

	public HashMap<String, HashMap<Integer, String>> getAgentView_DPOP_TSMap() {
		return agentView_DPOP_TSMap;
	}

	public void setAgentView_DPOP_TSMap(
			HashMap<String, HashMap<Integer, String>> agentView_DPOP_TSMap) {
		this.agentView_DPOP_TSMap = agentView_DPOP_TSMap;
	}

	public long getEndTime() {
		return endTime;
	}

	public void setEndTime(long endTime) {
		this.endTime = endTime;
	}

	public long getStartTime() {
		return startTime;
	}

	public void setStartTime(long startTime) {
		this.startTime = startTime;
	}

	public int getLsIteration() {
		return lsIteration;
	}

	public void setLsIteration(int lsIteration) {
		this.lsIteration = lsIteration;
	}
	
	public void incrementLsIteration() {
		this.lsIteration++;
	}

	public ArrayList<Double> getBestImproveUtilityList() {
		return bestImproveUtilityList;
	}

	public void setBestImproveUtilityList(ArrayList<Double> bestImproveUtilityList) {
		this.bestImproveUtilityList = bestImproveUtilityList;
	}

	public ArrayList<String> getBestImproveValueList() {
		return bestImproveValueList;
	}

	public void setBestImproveValueList(ArrayList<String> bestImproveValueList) {
		this.bestImproveValueList = bestImproveValueList;
	}

	public double getOldLSUtility() {
		return oldLSUtility;
	}

	public void setOldLSUtility(double oldLSUtility) {
		this.oldLSUtility = oldLSUtility;
	}
	
	public boolean isStop() {
		return stop;
	}

	public void setStop(boolean stop) {
		this.stop = stop;
	}
	
	public double getOldLSRunningTime() {
		return oldLSRunningTime;
	}

	public void setOldLSRunningTime(double oldLSRunningTime) {
		this.oldLSRunningTime = oldLSRunningTime;
	}
	
	public double getUtilityAndCost() {
		return utilityAndCost;
	}

	public void setUtilityAndCost(double utilityAndCost) {
		this.utilityAndCost = utilityAndCost;
	}
	
	public HashMap<String, String> getValuesToSendInVALUEPhase() {
		return valuesToSendInVALUEPhase;
	}

	public void setValuesToSendInVALUEPhase(
			HashMap<String, String> valuesToSendInVALUEPhase) {
		this.valuesToSendInVALUEPhase = valuesToSendInVALUEPhase;
	}
	
	public void addValuesToSendInValuePhase(String agent, String value) {
		this.valuesToSendInVALUEPhase.put(agent, value);
	}
	
	public HashMap<Integer, String> getPickedRandomMap() {
		return pickedRandomMap;
	}

	public void setPickedRandomMap(HashMap<Integer, String> pickedRandomMap) {
		this.pickedRandomMap = pickedRandomMap;
	}
	
	public void addPickedRandomMap(Integer timeStep, String pickedRandomValue) {
		this.pickedRandomMap.put(timeStep, pickedRandomValue);
	}
	
	public String getPickedRandomAt(Integer timeStep) {
		return this.pickedRandomMap.get(timeStep);
	}
	
    public long getCurrentUTILstartTime() {
		return currentUTILstartTime;
	}

	public void setCurrentUTILstartTime(long currentUTILstartTime) {
		this.currentUTILstartTime = currentUTILstartTime;
	}
	
	public String getLastLine() {
		return lastLine;
	}

	public void setLastLine(String lastLine) {
		this.lastLine = lastLine;
	}
	
	public double[] toArray(ArrayList<Double> arrayList) {
		int arrSize = arrayList.size();
		double[] convertedArray = new double[arrSize];
		for (int i=0; i<arrSize; i++) {
			convertedArray[i] = arrayList.get(i);
		}
		return convertedArray;
	}
	
	//each row is a timeStep from 0 to finalTimeStep
	//each column is a value from domain
	public String simulateRandom(int currentTimeStep) {
		//randomVar is the same as decisionVar string
		String randomVar = idStr;
		double distribution[] = null;
		//if currentTimeStep = 0 -> get from initial distribution
		if (currentTimeStep == 0) {
			distribution = toArray(initProabilityMap.get(randomVar));
		}
		//get distribution from transition function, from the previous random values
		else {
			String previousRandValue = getPickedRandomAt(currentTimeStep-1);
			distribution = toArray(transitionFunctionMap.get(randomVar).getTransitionOf(previousRandValue));
		}

		double rand = Math.random();
		double accumualatedProbability = 0;
		for (int i=0; i<distribution.length; i++) {
			accumualatedProbability += distribution[i];
			if (rand < accumualatedProbability)
				return randomVariableDomainMap.get(randomVar).get(i);
		}
		return null;
	}
	
	public void addReactRandomTableToList(int timeStep) {
		//traverse to each random table
		for (Table randTable:organizedConstraintTableWithRandomList) {
			ArrayList<String> decLabel = randTable.getDecVarLabel();
			//at current time step, create a new table, simulate the random, and add the corresponding random values
			
			Table newTable = new Table(decLabel);
			String simulatedRandomValues = simulateRandom(timeStep);
			addPickedRandomMap(timeStep, simulatedRandomValues);
			
			for (Row row:randTable.getTable()) {
				if (row.getRandomList().get(0).equals(simulatedRandomValues))
					newTable.addRow(new Row(row.getValueList(), row.getUtility()));
			}
			constraintTableAtEachTSMap.get(timeStep).add(newTable);
		}
	}
	
	public static double[] multiply(double[] vector, TransitionFunction transFunc) {
		int size = vector.length;
		if (size != transFunc.getSize()) {
			System.err.println("Not a square matrix");
			return null;
		}
		
		double resultVector[] = new double[size];
		for (int col=0; col<size; col++) {
			for (int k=0; k<size; k++) {
				resultVector[col] += vector[k] * transFunc.getProbByIndex(k,col);
			}
		}
		
		return resultVector;
	}
	
	public double sc_func(String oldValue, String newValue) {
		boolean equal = oldValue.equals(newValue); 
		double difference = Math.abs(Double.parseDouble(oldValue) - Double.parseDouble(newValue));
		
		switch (scType) {
		case CONSTANT:
			return equal ? 0 : switchingCost;
		case LINEAR:
			return equal ? 0 : switchingCost * difference;
		case QUAD:
			return equal ? 0 : switchingCost * Math.pow(difference, 2);
		case EXP_2:
			return equal ? 0 : switchingCost * Math.pow(2, difference);
		case EXP_3:
			return equal ? 0 : switchingCost * Math.pow(3, difference);
		}
		
		return -Double.MAX_VALUE;
			
	}
}	
